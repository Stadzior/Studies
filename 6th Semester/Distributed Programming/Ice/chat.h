// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `chat.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __chat_h__
#define __chat_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace IceProxy
{

namespace Chat
{

class ChatRoom;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatRoom>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::ChatRoom*);

class ChatFactory;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatFactory>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::ChatFactory*);

class User;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::User>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::User*);

class ChatServer;
void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatServer>&);
::IceProxy::Ice::Object* upCast(::IceProxy::Chat::ChatServer*);

}

}

namespace Chat
{

class ChatRoom;
bool operator==(const ChatRoom&, const ChatRoom&);
bool operator<(const ChatRoom&, const ChatRoom&);
::Ice::Object* upCast(::Chat::ChatRoom*);
typedef ::IceInternal::Handle< ::Chat::ChatRoom> ChatRoomPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatRoom> ChatRoomPrx;
void __patch(ChatRoomPtr&, const ::Ice::ObjectPtr&);

class ChatFactory;
bool operator==(const ChatFactory&, const ChatFactory&);
bool operator<(const ChatFactory&, const ChatFactory&);
::Ice::Object* upCast(::Chat::ChatFactory*);
typedef ::IceInternal::Handle< ::Chat::ChatFactory> ChatFactoryPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatFactory> ChatFactoryPrx;
void __patch(ChatFactoryPtr&, const ::Ice::ObjectPtr&);

class User;
bool operator==(const User&, const User&);
bool operator<(const User&, const User&);
::Ice::Object* upCast(::Chat::User*);
typedef ::IceInternal::Handle< ::Chat::User> UserPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::User> UserPrx;
void __patch(UserPtr&, const ::Ice::ObjectPtr&);

class ChatServer;
bool operator==(const ChatServer&, const ChatServer&);
bool operator<(const ChatServer&, const ChatServer&);
::Ice::Object* upCast(::Chat::ChatServer*);
typedef ::IceInternal::Handle< ::Chat::ChatServer> ChatServerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatServer> ChatServerPrx;
void __patch(ChatServerPtr&, const ::Ice::ObjectPtr&);

}

namespace Chat
{

class UserNotFound : public ::Ice::UserException
{
public:

    UserNotFound() {}
    virtual ~UserNotFound() throw();

    virtual ::std::string ice_name() const;
    virtual UserNotFound* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

static UserNotFound __UserNotFound_init;

class AuthenticationError : public ::Ice::UserException
{
public:

    AuthenticationError() {}
    virtual ~AuthenticationError() throw();

    virtual ::std::string ice_name() const;
    virtual AuthenticationError* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

class EmptyUsername : public ::Ice::UserException
{
public:

    EmptyUsername() {}
    virtual ~EmptyUsername() throw();

    virtual ::std::string ice_name() const;
    virtual EmptyUsername* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

class RoomNotFound : public ::Ice::UserException
{
public:

    RoomNotFound() {}
    virtual ~RoomNotFound() throw();

    virtual ::std::string ice_name() const;
    virtual RoomNotFound* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

class UserAlreadyRegistered : public ::Ice::UserException
{
public:

    UserAlreadyRegistered() {}
    virtual ~UserAlreadyRegistered() throw();

    virtual ::std::string ice_name() const;
    virtual UserAlreadyRegistered* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

class FactoryNotRegistered : public ::Ice::UserException
{
public:

    FactoryNotRegistered() {}
    virtual ~FactoryNotRegistered() throw();

    virtual ::std::string ice_name() const;
    virtual FactoryNotRegistered* ice_clone() const;
    virtual void ice_throw() const;

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::UserException::__writeImpl;
    using ::Ice::UserException::__readImpl;
    #endif
};

typedef ::std::vector< ::Chat::ChatRoomPrx> chatRoomList;

typedef ::std::vector< ::Chat::UserPrx> userList;

}

namespace Ice
{
template<>
struct StreamableTraits< ::Chat::UserNotFound>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::AuthenticationError>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::EmptyUsername>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::RoomNotFound>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::UserAlreadyRegistered>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

template<>
struct StreamableTraits< ::Chat::FactoryNotRegistered>
{
    static const StreamHelperCategory helper = StreamHelperCategoryUserException;
};

}

namespace Chat
{

class Callback_User_sendMessage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_sendMessage_Base> Callback_User_sendMessagePtr;

class Callback_User_sendPrivateMessage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_sendPrivateMessage_Base> Callback_User_sendPrivateMessagePtr;

class Callback_User_displayMessage_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_displayMessage_Base> Callback_User_displayMessagePtr;

class Callback_User_getName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_getName_Base> Callback_User_getNamePtr;

class Callback_User_setName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_setName_Base> Callback_User_setNamePtr;

class Callback_User_setPattern_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_setPattern_Base> Callback_User_setPatternPtr;

class Callback_User_joinRoom_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_joinRoom_Base> Callback_User_joinRoomPtr;

class Callback_User_exitRoom_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_exitRoom_Base> Callback_User_exitRoomPtr;

class Callback_User_getRooms_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_getRooms_Base> Callback_User_getRoomsPtr;

class Callback_User_findRoomByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_findRoomByName_Base> Callback_User_findRoomByNamePtr;

class Callback_User_getResponseForChallenge_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_User_getResponseForChallenge_Base> Callback_User_getResponseForChallengePtr;

class Callback_ChatServer_registerUser_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_registerUser_Base> Callback_ChatServer_registerUserPtr;

class Callback_ChatServer_login_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_login_Base> Callback_ChatServer_loginPtr;

class Callback_ChatServer_enterRoom_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_enterRoom_Base> Callback_ChatServer_enterRoomPtr;

class Callback_ChatServer_exitRoom_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_exitRoom_Base> Callback_ChatServer_exitRoomPtr;

class Callback_ChatServer_logout_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_logout_Base> Callback_ChatServer_logoutPtr;

class Callback_ChatServer_isLoggedIn_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_isLoggedIn_Base> Callback_ChatServer_isLoggedInPtr;

class Callback_ChatServer_getRooms_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_getRooms_Base> Callback_ChatServer_getRoomsPtr;

class Callback_ChatServer_findRoomByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_findRoomByName_Base> Callback_ChatServer_findRoomByNamePtr;

class Callback_ChatServer_findUserByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_findUserByName_Base> Callback_ChatServer_findUserByNamePtr;

class Callback_ChatServer_registerChatFactory_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatServer_registerChatFactory_Base> Callback_ChatServer_registerChatFactoryPtr;

class Callback_ChatRoom_sendMessageToAll_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatRoom_sendMessageToAll_Base> Callback_ChatRoom_sendMessageToAllPtr;

class Callback_ChatRoom_getName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatRoom_getName_Base> Callback_ChatRoom_getNamePtr;

class Callback_ChatRoom_setName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatRoom_setName_Base> Callback_ChatRoom_setNamePtr;

class Callback_ChatRoom_enterRoom_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatRoom_enterRoom_Base> Callback_ChatRoom_enterRoomPtr;

class Callback_ChatRoom_exitRoom_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatRoom_exitRoom_Base> Callback_ChatRoom_exitRoomPtr;

class Callback_ChatRoom_getUsers_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatRoom_getUsers_Base> Callback_ChatRoom_getUsersPtr;

class Callback_ChatRoom_findUserByName_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatRoom_findUserByName_Base> Callback_ChatRoom_findUserByNamePtr;

class Callback_ChatFactory_getNewChatRoom_Base : virtual public ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ChatFactory_getNewChatRoom_Base> Callback_ChatFactory_getNewChatRoomPtr;

}

namespace IceProxy
{

namespace Chat
{

class User : virtual public ::IceProxy::Ice::Object
{
public:

    void sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who)
    {
        sendMessage(message, room, who, 0);
    }
    void sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who, const ::Ice::Context& __ctx)
    {
        sendMessage(message, room, who, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendMessage(message, room, who, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendMessage(message, room, who, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendMessage(message, room, who, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendMessage(message, room, who, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who)
    {
        return begin_sendMessage(message, room, who, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who, const ::Ice::Context& __ctx)
    {
        return begin_sendMessage(message, room, who, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(message, room, who, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(message, room, who, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who, const ::Chat::Callback_User_sendMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(message, room, who, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who, const ::Ice::Context& __ctx, const ::Chat::Callback_User_sendMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessage(message, room, who, &__ctx, __del, __cookie);
    }

    void end_sendMessage(const ::Ice::AsyncResultPtr&);
    
private:

    void sendMessage(const ::std::string&, const ::Chat::ChatRoomPrx&, const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sendMessage(const ::std::string&, const ::Chat::ChatRoomPrx&, const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who)
    {
        sendPrivateMessage(message, who, 0);
    }
    void sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who, const ::Ice::Context& __ctx)
    {
        sendPrivateMessage(message, who, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendPrivateMessage(message, who, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendPrivateMessage(message, who, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendPrivateMessage(message, who, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendPrivateMessage(message, who, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who)
    {
        return begin_sendPrivateMessage(message, who, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who, const ::Ice::Context& __ctx)
    {
        return begin_sendPrivateMessage(message, who, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendPrivateMessage(message, who, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendPrivateMessage(message, who, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who, const ::Chat::Callback_User_sendPrivateMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendPrivateMessage(message, who, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who, const ::Ice::Context& __ctx, const ::Chat::Callback_User_sendPrivateMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendPrivateMessage(message, who, &__ctx, __del, __cookie);
    }

    void end_sendPrivateMessage(const ::Ice::AsyncResultPtr&);
    
private:

    void sendPrivateMessage(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sendPrivateMessage(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void displayMessage(const ::std::string& message)
    {
        displayMessage(message, 0);
    }
    void displayMessage(const ::std::string& message, const ::Ice::Context& __ctx)
    {
        displayMessage(message, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_displayMessage(const ::std::string& message, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_displayMessage(message, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_displayMessage(const ::std::string& message, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_displayMessage(message, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_displayMessage(const ::std::string& message, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_displayMessage(message, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_displayMessage(const ::std::string& message, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_displayMessage(message, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_displayMessage(const ::std::string& message)
    {
        return begin_displayMessage(message, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_displayMessage(const ::std::string& message, const ::Ice::Context& __ctx)
    {
        return begin_displayMessage(message, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_displayMessage(const ::std::string& message, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_displayMessage(message, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_displayMessage(const ::std::string& message, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_displayMessage(message, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_displayMessage(const ::std::string& message, const ::Chat::Callback_User_displayMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_displayMessage(message, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_displayMessage(const ::std::string& message, const ::Ice::Context& __ctx, const ::Chat::Callback_User_displayMessagePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_displayMessage(message, &__ctx, __del, __cookie);
    }

    void end_displayMessage(const ::Ice::AsyncResultPtr&);
    
private:

    void displayMessage(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_displayMessage(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getName()
    {
        return getName(0);
    }
    ::std::string getName(const ::Ice::Context& __ctx)
    {
        return getName(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getName(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getName(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getName(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getName(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getName(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getName(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getName(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getName(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getName(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_getName(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_getName(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getName()
    {
        return begin_getName(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx)
    {
        return begin_getName(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Chat::Callback_User_getNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx, const ::Chat::Callback_User_getNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(&__ctx, __del, __cookie);
    }

    ::std::string end_getName(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getName(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setName(const ::std::string& name)
    {
        setName(name, 0);
    }
    void setName(const ::std::string& name, const ::Ice::Context& __ctx)
    {
        setName(name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setName(const ::std::string& name, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_setName(name, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_setName(const ::std::string& name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setName(name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setName(const ::std::string& name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_setName(name, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setName(const ::std::string& name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setName(name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& name)
    {
        return begin_setName(name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& name, const ::Ice::Context& __ctx)
    {
        return begin_setName(name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& name, const ::Chat::Callback_User_setNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& name, const ::Ice::Context& __ctx, const ::Chat::Callback_User_setNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(name, &__ctx, __del, __cookie);
    }

    void end_setName(const ::Ice::AsyncResultPtr&);
    
private:

    void setName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setPattern(const ::std::string& pattern)
    {
        setPattern(pattern, 0);
    }
    void setPattern(const ::std::string& pattern, const ::Ice::Context& __ctx)
    {
        setPattern(pattern, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setPattern(const ::std::string& pattern, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_setPattern(pattern, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_setPattern(const ::std::string& pattern, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setPattern(pattern, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setPattern(const ::std::string& pattern, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_setPattern(pattern, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setPattern(const ::std::string& pattern, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setPattern(pattern, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_setPattern(const ::std::string& pattern)
    {
        return begin_setPattern(pattern, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPattern(const ::std::string& pattern, const ::Ice::Context& __ctx)
    {
        return begin_setPattern(pattern, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setPattern(const ::std::string& pattern, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPattern(pattern, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPattern(const ::std::string& pattern, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPattern(pattern, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPattern(const ::std::string& pattern, const ::Chat::Callback_User_setPatternPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPattern(pattern, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setPattern(const ::std::string& pattern, const ::Ice::Context& __ctx, const ::Chat::Callback_User_setPatternPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setPattern(pattern, &__ctx, __del, __cookie);
    }

    void end_setPattern(const ::Ice::AsyncResultPtr&);
    
private:

    void setPattern(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setPattern(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void joinRoom(const ::Chat::ChatRoomPrx& room)
    {
        joinRoom(room, 0);
    }
    void joinRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context& __ctx)
    {
        joinRoom(room, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_joinRoom(const ::Chat::ChatRoomPrx& room, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_joinRoom(room, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_joinRoom(const ::Chat::ChatRoomPrx& room, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_joinRoom(room, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_joinRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_joinRoom(room, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_joinRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_joinRoom(room, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_joinRoom(const ::Chat::ChatRoomPrx& room)
    {
        return begin_joinRoom(room, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_joinRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context& __ctx)
    {
        return begin_joinRoom(room, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_joinRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_joinRoom(room, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_joinRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_joinRoom(room, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_joinRoom(const ::Chat::ChatRoomPrx& room, const ::Chat::Callback_User_joinRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_joinRoom(room, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_joinRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context& __ctx, const ::Chat::Callback_User_joinRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_joinRoom(room, &__ctx, __del, __cookie);
    }

    void end_joinRoom(const ::Ice::AsyncResultPtr&);
    
private:

    void joinRoom(const ::Chat::ChatRoomPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_joinRoom(const ::Chat::ChatRoomPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void exitRoom(const ::Chat::ChatRoomPrx& room)
    {
        exitRoom(room, 0);
    }
    void exitRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context& __ctx)
    {
        exitRoom(room, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_exitRoom(const ::Chat::ChatRoomPrx& room, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_exitRoom(room, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_exitRoom(const ::Chat::ChatRoomPrx& room, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_exitRoom(room, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_exitRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_exitRoom(room, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_exitRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_exitRoom(room, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::ChatRoomPrx& room)
    {
        return begin_exitRoom(room, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context& __ctx)
    {
        return begin_exitRoom(room, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exitRoom(room, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exitRoom(room, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::ChatRoomPrx& room, const ::Chat::Callback_User_exitRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exitRoom(room, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context& __ctx, const ::Chat::Callback_User_exitRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exitRoom(room, &__ctx, __del, __cookie);
    }

    void end_exitRoom(const ::Ice::AsyncResultPtr&);
    
private:

    void exitRoom(const ::Chat::ChatRoomPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::ChatRoomPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::chatRoomList getRooms()
    {
        return getRooms(0);
    }
    ::Chat::chatRoomList getRooms(const ::Ice::Context& __ctx)
    {
        return getRooms(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getRooms(const ::IceInternal::Function<void (const ::Chat::chatRoomList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRooms(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRooms(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRooms(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getRooms(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::chatRoomList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRooms(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRooms(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRooms(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getRooms(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::chatRoomList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Chat::chatRoomList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
                ::Chat::chatRoomList __ret;
                try
                {
                    __ret = __proxy->end_getRooms(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Chat::chatRoomList&)> _response;
        };
        return begin_getRooms(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getRooms()
    {
        return begin_getRooms(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRooms(const ::Ice::Context& __ctx)
    {
        return begin_getRooms(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRooms(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRooms(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRooms(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRooms(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRooms(const ::Chat::Callback_User_getRoomsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRooms(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRooms(const ::Ice::Context& __ctx, const ::Chat::Callback_User_getRoomsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRooms(&__ctx, __del, __cookie);
    }

    ::Chat::chatRoomList end_getRooms(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::chatRoomList getRooms(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRooms(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::ChatRoomPrx findRoomByName(const ::std::string& roomName)
    {
        return findRoomByName(roomName, 0);
    }
    ::Chat::ChatRoomPrx findRoomByName(const ::std::string& roomName, const ::Ice::Context& __ctx)
    {
        return findRoomByName(roomName, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_findRoomByName(const ::std::string& roomName, const ::IceInternal::Function<void (const ::Chat::ChatRoomPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_findRoomByName(roomName, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_findRoomByName(const ::std::string& roomName, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_findRoomByName(roomName, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_findRoomByName(const ::std::string& roomName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::ChatRoomPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_findRoomByName(roomName, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_findRoomByName(const ::std::string& roomName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_findRoomByName(roomName, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_findRoomByName(const ::std::string& roomName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::ChatRoomPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Chat::ChatRoomPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
                ::Chat::ChatRoomPrx __ret;
                try
                {
                    __ret = __proxy->end_findRoomByName(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Chat::ChatRoomPrx&)> _response;
        };
        return begin_findRoomByName(roomName, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_findRoomByName(const ::std::string& roomName)
    {
        return begin_findRoomByName(roomName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findRoomByName(const ::std::string& roomName, const ::Ice::Context& __ctx)
    {
        return begin_findRoomByName(roomName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findRoomByName(const ::std::string& roomName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findRoomByName(roomName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findRoomByName(const ::std::string& roomName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findRoomByName(roomName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findRoomByName(const ::std::string& roomName, const ::Chat::Callback_User_findRoomByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findRoomByName(roomName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findRoomByName(const ::std::string& roomName, const ::Ice::Context& __ctx, const ::Chat::Callback_User_findRoomByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findRoomByName(roomName, &__ctx, __del, __cookie);
    }

    ::Chat::ChatRoomPrx end_findRoomByName(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::ChatRoomPrx findRoomByName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_findRoomByName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getResponseForChallenge(const ::std::string& challenge)
    {
        return getResponseForChallenge(challenge, 0);
    }
    ::std::string getResponseForChallenge(const ::std::string& challenge, const ::Ice::Context& __ctx)
    {
        return getResponseForChallenge(challenge, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getResponseForChallenge(const ::std::string& challenge, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getResponseForChallenge(challenge, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getResponseForChallenge(const ::std::string& challenge, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getResponseForChallenge(challenge, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getResponseForChallenge(const ::std::string& challenge, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getResponseForChallenge(challenge, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getResponseForChallenge(const ::std::string& challenge, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getResponseForChallenge(challenge, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getResponseForChallenge(const ::std::string& challenge, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_getResponseForChallenge(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_getResponseForChallenge(challenge, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getResponseForChallenge(const ::std::string& challenge)
    {
        return begin_getResponseForChallenge(challenge, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getResponseForChallenge(const ::std::string& challenge, const ::Ice::Context& __ctx)
    {
        return begin_getResponseForChallenge(challenge, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getResponseForChallenge(const ::std::string& challenge, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getResponseForChallenge(challenge, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getResponseForChallenge(const ::std::string& challenge, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getResponseForChallenge(challenge, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getResponseForChallenge(const ::std::string& challenge, const ::Chat::Callback_User_getResponseForChallengePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getResponseForChallenge(challenge, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getResponseForChallenge(const ::std::string& challenge, const ::Ice::Context& __ctx, const ::Chat::Callback_User_getResponseForChallengePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getResponseForChallenge(challenge, &__ctx, __del, __cookie);
    }

    ::std::string end_getResponseForChallenge(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getResponseForChallenge(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getResponseForChallenge(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<User> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_secure(bool __secure) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_twoway() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_oneway() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_batchOneway() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_datagram() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_batchDatagram() const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_compress(bool __compress) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_timeout(int __timeout) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<User> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<User*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ChatServer : virtual public ::IceProxy::Ice::Object
{
public:

    void registerUser(const ::std::string& username, const ::std::string& challengePattern)
    {
        registerUser(username, challengePattern, 0);
    }
    void registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::Ice::Context& __ctx)
    {
        registerUser(username, challengePattern, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_registerUser(username, challengePattern, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_registerUser(username, challengePattern, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_registerUser(username, challengePattern, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_registerUser(username, challengePattern, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_registerUser(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_registerUser(username, challengePattern, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_registerUser(const ::std::string& username, const ::std::string& challengePattern)
    {
        return begin_registerUser(username, challengePattern, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::Ice::Context& __ctx)
    {
        return begin_registerUser(username, challengePattern, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(username, challengePattern, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(username, challengePattern, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::Chat::Callback_ChatServer_registerUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(username, challengePattern, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_registerUserPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerUser(username, challengePattern, &__ctx, __del, __cookie);
    }

    void end_registerUser(const ::Ice::AsyncResultPtr&);
    
private:

    void registerUser(const ::std::string&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_registerUser(const ::std::string&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void login(const ::Chat::UserPrx& u)
    {
        login(u, 0);
    }
    void login(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx)
    {
        login(u, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_login(const ::Chat::UserPrx& u, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_login(u, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_login(const ::Chat::UserPrx& u, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_login(u, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_login(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_login(u, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_login(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_login(u, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_login(const ::Chat::UserPrx& u, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_login(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_login(u, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_login(const ::Chat::UserPrx& u)
    {
        return begin_login(u, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_login(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx)
    {
        return begin_login(u, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_login(const ::Chat::UserPrx& u, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(u, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(u, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login(const ::Chat::UserPrx& u, const ::Chat::Callback_ChatServer_loginPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(u, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_login(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_loginPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_login(u, &__ctx, __del, __cookie);
    }

    void end_login(const ::Ice::AsyncResultPtr&);
    
private:

    void login(const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_login(const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void enterRoom(const ::Chat::UserPrx& u, const ::std::string& room)
    {
        enterRoom(u, room, 0);
    }
    void enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context& __ctx)
    {
        enterRoom(u, room, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_enterRoom(u, room, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_enterRoom(u, room, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_enterRoom(u, room, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_enterRoom(u, room, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context* __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void ()>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
                try
                {
                    __proxy->end_enterRoom(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response();
                }
            }
        
        private:
            
            ::std::function<void ()> _response;
        };
        return begin_enterRoom(u, room, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_enterRoom(const ::Chat::UserPrx& u, const ::std::string& room)
    {
        return begin_enterRoom(u, room, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context& __ctx)
    {
        return begin_enterRoom(u, room, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_enterRoom(u, room, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_enterRoom(u, room, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Chat::Callback_ChatServer_enterRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_enterRoom(u, room, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_enterRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_enterRoom(u, room, &__ctx, __del, __cookie);
    }

    void end_enterRoom(const ::Ice::AsyncResultPtr&);
    
private:

    void enterRoom(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_enterRoom(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void exitRoom(const ::Chat::UserPrx& u, const ::std::string& room)
    {
        exitRoom(u, room, 0);
    }
    void exitRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context& __ctx)
    {
        exitRoom(u, room, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_exitRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_exitRoom(u, room, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_exitRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_exitRoom(u, room, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_exitRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_exitRoom(u, room, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_exitRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_exitRoom(u, room, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::UserPrx& u, const ::std::string& room)
    {
        return begin_exitRoom(u, room, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context& __ctx)
    {
        return begin_exitRoom(u, room, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exitRoom(u, room, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exitRoom(u, room, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Chat::Callback_ChatServer_exitRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exitRoom(u, room, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_exitRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exitRoom(u, room, &__ctx, __del, __cookie);
    }

    void end_exitRoom(const ::Ice::AsyncResultPtr&);
    
private:

    void exitRoom(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void logout(const ::Chat::UserPrx& u)
    {
        logout(u, 0);
    }
    void logout(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx)
    {
        logout(u, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_logout(const ::Chat::UserPrx& u, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_logout(u, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_logout(const ::Chat::UserPrx& u, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_logout(u, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_logout(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_logout(u, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_logout(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_logout(u, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_logout(const ::Chat::UserPrx& u)
    {
        return begin_logout(u, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx)
    {
        return begin_logout(u, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::Chat::UserPrx& u, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logout(u, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logout(u, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::Chat::UserPrx& u, const ::Chat::Callback_ChatServer_logoutPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logout(u, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_logout(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_logoutPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_logout(u, &__ctx, __del, __cookie);
    }

    void end_logout(const ::Ice::AsyncResultPtr&);
    
private:

    void logout(const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_logout(const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    bool isLoggedIn(const ::Chat::UserPrx& u)
    {
        return isLoggedIn(u, 0);
    }
    bool isLoggedIn(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx)
    {
        return isLoggedIn(u, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_isLoggedIn(const ::Chat::UserPrx& u, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_isLoggedIn(u, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_isLoggedIn(const ::Chat::UserPrx& u, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_isLoggedIn(u, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_isLoggedIn(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_isLoggedIn(u, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_isLoggedIn(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_isLoggedIn(u, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_isLoggedIn(const ::Chat::UserPrx& u, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (bool)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (bool)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
                bool __ret;
                try
                {
                    __ret = __proxy->end_isLoggedIn(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (bool)> _response;
        };
        return begin_isLoggedIn(u, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_isLoggedIn(const ::Chat::UserPrx& u)
    {
        return begin_isLoggedIn(u, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isLoggedIn(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx)
    {
        return begin_isLoggedIn(u, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_isLoggedIn(const ::Chat::UserPrx& u, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isLoggedIn(u, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isLoggedIn(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isLoggedIn(u, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isLoggedIn(const ::Chat::UserPrx& u, const ::Chat::Callback_ChatServer_isLoggedInPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isLoggedIn(u, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_isLoggedIn(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_isLoggedInPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_isLoggedIn(u, &__ctx, __del, __cookie);
    }

    bool end_isLoggedIn(const ::Ice::AsyncResultPtr&);
    
private:

    bool isLoggedIn(const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_isLoggedIn(const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::chatRoomList getRooms()
    {
        return getRooms(0);
    }
    ::Chat::chatRoomList getRooms(const ::Ice::Context& __ctx)
    {
        return getRooms(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getRooms(const ::IceInternal::Function<void (const ::Chat::chatRoomList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRooms(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRooms(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRooms(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getRooms(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::chatRoomList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getRooms(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getRooms(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getRooms(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getRooms(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::chatRoomList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Chat::chatRoomList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
                ::Chat::chatRoomList __ret;
                try
                {
                    __ret = __proxy->end_getRooms(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Chat::chatRoomList&)> _response;
        };
        return begin_getRooms(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getRooms()
    {
        return begin_getRooms(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRooms(const ::Ice::Context& __ctx)
    {
        return begin_getRooms(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getRooms(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRooms(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRooms(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRooms(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRooms(const ::Chat::Callback_ChatServer_getRoomsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRooms(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getRooms(const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_getRoomsPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getRooms(&__ctx, __del, __cookie);
    }

    ::Chat::chatRoomList end_getRooms(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::chatRoomList getRooms(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getRooms(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::ChatRoomPrx findRoomByName(const ::std::string& roomName)
    {
        return findRoomByName(roomName, 0);
    }
    ::Chat::ChatRoomPrx findRoomByName(const ::std::string& roomName, const ::Ice::Context& __ctx)
    {
        return findRoomByName(roomName, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_findRoomByName(const ::std::string& roomName, const ::IceInternal::Function<void (const ::Chat::ChatRoomPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_findRoomByName(roomName, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_findRoomByName(const ::std::string& roomName, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_findRoomByName(roomName, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_findRoomByName(const ::std::string& roomName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::ChatRoomPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_findRoomByName(roomName, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_findRoomByName(const ::std::string& roomName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_findRoomByName(roomName, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_findRoomByName(const ::std::string& roomName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::ChatRoomPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Chat::ChatRoomPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
                ::Chat::ChatRoomPrx __ret;
                try
                {
                    __ret = __proxy->end_findRoomByName(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Chat::ChatRoomPrx&)> _response;
        };
        return begin_findRoomByName(roomName, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_findRoomByName(const ::std::string& roomName)
    {
        return begin_findRoomByName(roomName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findRoomByName(const ::std::string& roomName, const ::Ice::Context& __ctx)
    {
        return begin_findRoomByName(roomName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findRoomByName(const ::std::string& roomName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findRoomByName(roomName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findRoomByName(const ::std::string& roomName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findRoomByName(roomName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findRoomByName(const ::std::string& roomName, const ::Chat::Callback_ChatServer_findRoomByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findRoomByName(roomName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findRoomByName(const ::std::string& roomName, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_findRoomByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findRoomByName(roomName, &__ctx, __del, __cookie);
    }

    ::Chat::ChatRoomPrx end_findRoomByName(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::ChatRoomPrx findRoomByName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_findRoomByName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::UserPrx findUserByName(const ::std::string& username)
    {
        return findUserByName(username, 0);
    }
    ::Chat::UserPrx findUserByName(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        return findUserByName(username, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_findUserByName(const ::std::string& username, const ::IceInternal::Function<void (const ::Chat::UserPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_findUserByName(username, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_findUserByName(const ::std::string& username, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_findUserByName(username, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_findUserByName(const ::std::string& username, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::UserPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_findUserByName(username, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_findUserByName(const ::std::string& username, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_findUserByName(username, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_findUserByName(const ::std::string& username, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::UserPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Chat::UserPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
                ::Chat::UserPrx __ret;
                try
                {
                    __ret = __proxy->end_findUserByName(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Chat::UserPrx&)> _response;
        };
        return begin_findUserByName(username, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_findUserByName(const ::std::string& username)
    {
        return begin_findUserByName(username, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findUserByName(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        return begin_findUserByName(username, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findUserByName(const ::std::string& username, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findUserByName(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findUserByName(const ::std::string& username, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findUserByName(username, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findUserByName(const ::std::string& username, const ::Chat::Callback_ChatServer_findUserByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findUserByName(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findUserByName(const ::std::string& username, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_findUserByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findUserByName(username, &__ctx, __del, __cookie);
    }

    ::Chat::UserPrx end_findUserByName(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::UserPrx findUserByName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_findUserByName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void registerChatFactory(const ::Chat::ChatFactoryPrx& cf)
    {
        registerChatFactory(cf, 0);
    }
    void registerChatFactory(const ::Chat::ChatFactoryPrx& cf, const ::Ice::Context& __ctx)
    {
        registerChatFactory(cf, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_registerChatFactory(const ::Chat::ChatFactoryPrx& cf, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_registerChatFactory(cf, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_registerChatFactory(const ::Chat::ChatFactoryPrx& cf, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_registerChatFactory(cf, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_registerChatFactory(const ::Chat::ChatFactoryPrx& cf, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_registerChatFactory(cf, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_registerChatFactory(const ::Chat::ChatFactoryPrx& cf, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_registerChatFactory(cf, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_registerChatFactory(const ::Chat::ChatFactoryPrx& cf)
    {
        return begin_registerChatFactory(cf, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerChatFactory(const ::Chat::ChatFactoryPrx& cf, const ::Ice::Context& __ctx)
    {
        return begin_registerChatFactory(cf, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_registerChatFactory(const ::Chat::ChatFactoryPrx& cf, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerChatFactory(cf, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerChatFactory(const ::Chat::ChatFactoryPrx& cf, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerChatFactory(cf, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerChatFactory(const ::Chat::ChatFactoryPrx& cf, const ::Chat::Callback_ChatServer_registerChatFactoryPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerChatFactory(cf, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_registerChatFactory(const ::Chat::ChatFactoryPrx& cf, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatServer_registerChatFactoryPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_registerChatFactory(cf, &__ctx, __del, __cookie);
    }

    void end_registerChatFactory(const ::Ice::AsyncResultPtr&);
    
private:

    void registerChatFactory(const ::Chat::ChatFactoryPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_registerChatFactory(const ::Chat::ChatFactoryPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ChatServer> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_secure(bool __secure) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_twoway() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_oneway() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_batchOneway() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_datagram() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_batchDatagram() const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_compress(bool __compress) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ChatServer> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ChatServer*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ChatRoom : virtual public ::IceProxy::Ice::Object
{
public:

    void sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message)
    {
        sendMessageToAll(who, message, 0);
    }
    void sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message, const ::Ice::Context& __ctx)
    {
        sendMessageToAll(who, message, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendMessageToAll(who, message, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendMessageToAll(who, message, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_sendMessageToAll(who, message, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_sendMessageToAll(who, message, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message)
    {
        return begin_sendMessageToAll(who, message, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message, const ::Ice::Context& __ctx)
    {
        return begin_sendMessageToAll(who, message, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessageToAll(who, message, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessageToAll(who, message, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message, const ::Chat::Callback_ChatRoom_sendMessageToAllPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessageToAll(who, message, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatRoom_sendMessageToAllPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_sendMessageToAll(who, message, &__ctx, __del, __cookie);
    }

    void end_sendMessageToAll(const ::Ice::AsyncResultPtr&);
    
private:

    void sendMessageToAll(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_sendMessageToAll(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::std::string getName()
    {
        return getName(0);
    }
    ::std::string getName(const ::Ice::Context& __ctx)
    {
        return getName(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getName(const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getName(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getName(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getName(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getName(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getName(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getName(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getName(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getName(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::std::string&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::std::string&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::ChatRoomPrx __proxy = ::Chat::ChatRoomPrx::uncheckedCast(__result->getProxy());
                ::std::string __ret;
                try
                {
                    __ret = __proxy->end_getName(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::std::string&)> _response;
        };
        return begin_getName(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getName()
    {
        return begin_getName(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx)
    {
        return begin_getName(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Chat::Callback_ChatRoom_getNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context& __ctx, const ::Chat::Callback_ChatRoom_getNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getName(&__ctx, __del, __cookie);
    }

    ::std::string end_getName(const ::Ice::AsyncResultPtr&);
    
private:

    ::std::string getName(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getName(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void setName(const ::std::string& name)
    {
        setName(name, 0);
    }
    void setName(const ::std::string& name, const ::Ice::Context& __ctx)
    {
        setName(name, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_setName(const ::std::string& name, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_setName(name, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_setName(const ::std::string& name, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setName(name, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setName(const ::std::string& name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_setName(name, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_setName(const ::std::string& name, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_setName(name, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& name)
    {
        return begin_setName(name, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& name, const ::Ice::Context& __ctx)
    {
        return begin_setName(name, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& name, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& name, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(name, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& name, const ::Chat::Callback_ChatRoom_setNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(name, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_setName(const ::std::string& name, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatRoom_setNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_setName(name, &__ctx, __del, __cookie);
    }

    void end_setName(const ::Ice::AsyncResultPtr&);
    
private:

    void setName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_setName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void enterRoom(const ::Chat::UserPrx& u)
    {
        enterRoom(u, 0);
    }
    void enterRoom(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx)
    {
        enterRoom(u, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_enterRoom(const ::Chat::UserPrx& u, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_enterRoom(u, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_enterRoom(const ::Chat::UserPrx& u, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_enterRoom(u, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_enterRoom(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_enterRoom(u, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_enterRoom(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_enterRoom(u, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_enterRoom(const ::Chat::UserPrx& u)
    {
        return begin_enterRoom(u, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_enterRoom(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx)
    {
        return begin_enterRoom(u, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_enterRoom(const ::Chat::UserPrx& u, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_enterRoom(u, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_enterRoom(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_enterRoom(u, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_enterRoom(const ::Chat::UserPrx& u, const ::Chat::Callback_ChatRoom_enterRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_enterRoom(u, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_enterRoom(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatRoom_enterRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_enterRoom(u, &__ctx, __del, __cookie);
    }

    void end_enterRoom(const ::Ice::AsyncResultPtr&);
    
private:

    void enterRoom(const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_enterRoom(const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    void exitRoom(const ::Chat::UserPrx& u)
    {
        exitRoom(u, 0);
    }
    void exitRoom(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx)
    {
        exitRoom(u, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_exitRoom(const ::Chat::UserPrx& u, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_exitRoom(u, 0, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent));
    }
    ::Ice::AsyncResultPtr
    begin_exitRoom(const ::Chat::UserPrx& u, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_exitRoom(u, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_exitRoom(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::IceInternal::Function<void ()>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return begin_exitRoom(u, &__ctx, new ::IceInternal::Cpp11FnOnewayCallbackNC(__response, __exception, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_exitRoom(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_exitRoom(u, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
#endif

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::UserPrx& u)
    {
        return begin_exitRoom(u, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx)
    {
        return begin_exitRoom(u, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::UserPrx& u, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exitRoom(u, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exitRoom(u, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::UserPrx& u, const ::Chat::Callback_ChatRoom_exitRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exitRoom(u, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::UserPrx& u, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatRoom_exitRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_exitRoom(u, &__ctx, __del, __cookie);
    }

    void end_exitRoom(const ::Ice::AsyncResultPtr&);
    
private:

    void exitRoom(const ::Chat::UserPrx&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_exitRoom(const ::Chat::UserPrx&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::userList getUsers()
    {
        return getUsers(0);
    }
    ::Chat::userList getUsers(const ::Ice::Context& __ctx)
    {
        return getUsers(&__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getUsers(const ::IceInternal::Function<void (const ::Chat::userList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUsers(0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUsers(const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUsers(0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getUsers(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::userList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getUsers(&__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getUsers(const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getUsers(&__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getUsers(const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::userList&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Chat::userList&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::ChatRoomPrx __proxy = ::Chat::ChatRoomPrx::uncheckedCast(__result->getProxy());
                ::Chat::userList __ret;
                try
                {
                    __ret = __proxy->end_getUsers(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Chat::userList&)> _response;
        };
        return begin_getUsers(__ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getUsers()
    {
        return begin_getUsers(0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUsers(const ::Ice::Context& __ctx)
    {
        return begin_getUsers(&__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getUsers(const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsers(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsers(const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsers(&__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsers(const ::Chat::Callback_ChatRoom_getUsersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsers(0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getUsers(const ::Ice::Context& __ctx, const ::Chat::Callback_ChatRoom_getUsersPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getUsers(&__ctx, __del, __cookie);
    }

    ::Chat::userList end_getUsers(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::userList getUsers(const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getUsers(const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:

    ::Chat::UserPrx findUserByName(const ::std::string& username)
    {
        return findUserByName(username, 0);
    }
    ::Chat::UserPrx findUserByName(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        return findUserByName(username, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_findUserByName(const ::std::string& username, const ::IceInternal::Function<void (const ::Chat::UserPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_findUserByName(username, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_findUserByName(const ::std::string& username, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_findUserByName(username, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_findUserByName(const ::std::string& username, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::UserPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_findUserByName(username, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_findUserByName(const ::std::string& username, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_findUserByName(username, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_findUserByName(const ::std::string& username, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::UserPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Chat::UserPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::ChatRoomPrx __proxy = ::Chat::ChatRoomPrx::uncheckedCast(__result->getProxy());
                ::Chat::UserPrx __ret;
                try
                {
                    __ret = __proxy->end_findUserByName(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Chat::UserPrx&)> _response;
        };
        return begin_findUserByName(username, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_findUserByName(const ::std::string& username)
    {
        return begin_findUserByName(username, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findUserByName(const ::std::string& username, const ::Ice::Context& __ctx)
    {
        return begin_findUserByName(username, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_findUserByName(const ::std::string& username, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findUserByName(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findUserByName(const ::std::string& username, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findUserByName(username, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findUserByName(const ::std::string& username, const ::Chat::Callback_ChatRoom_findUserByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findUserByName(username, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_findUserByName(const ::std::string& username, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatRoom_findUserByNamePtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_findUserByName(username, &__ctx, __del, __cookie);
    }

    ::Chat::UserPrx end_findUserByName(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::UserPrx findUserByName(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_findUserByName(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_secure(bool __secure) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_twoway() const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_oneway() const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_batchOneway() const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_datagram() const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_batchDatagram() const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_compress(bool __compress) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ChatRoom> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ChatRoom*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ChatFactory : virtual public ::IceProxy::Ice::Object
{
public:

    ::Chat::ChatRoomPrx getNewChatRoom(const ::std::string& roomName)
    {
        return getNewChatRoom(roomName, 0);
    }
    ::Chat::ChatRoomPrx getNewChatRoom(const ::std::string& roomName, const ::Ice::Context& __ctx)
    {
        return getNewChatRoom(roomName, &__ctx);
    }
#ifdef ICE_CPP11
    ::Ice::AsyncResultPtr
    begin_getNewChatRoom(const ::std::string& roomName, const ::IceInternal::Function<void (const ::Chat::ChatRoomPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getNewChatRoom(roomName, 0, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getNewChatRoom(const ::std::string& roomName, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getNewChatRoom(roomName, 0, ::Ice::newCallback(__completed, __sent), 0);
    }
    ::Ice::AsyncResultPtr
    begin_getNewChatRoom(const ::std::string& roomName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Chat::ChatRoomPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception = ::IceInternal::Function<void (const ::Ice::Exception&)>(), const ::IceInternal::Function<void (bool)>& __sent = ::IceInternal::Function<void (bool)>())
    {
        return __begin_getNewChatRoom(roomName, &__ctx, __response, __exception, __sent);
    }
    ::Ice::AsyncResultPtr
    begin_getNewChatRoom(const ::std::string& roomName, const ::Ice::Context& __ctx, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __completed, const ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>& __sent = ::IceInternal::Function<void (const ::Ice::AsyncResultPtr&)>())
    {
        return begin_getNewChatRoom(roomName, &__ctx, ::Ice::newCallback(__completed, __sent));
    }
    
private:

    ::Ice::AsyncResultPtr __begin_getNewChatRoom(const ::std::string& roomName, const ::Ice::Context* __ctx, const ::IceInternal::Function<void (const ::Chat::ChatRoomPrx&)>& __response, const ::IceInternal::Function<void (const ::Ice::Exception&)>& __exception, const ::IceInternal::Function<void (bool)>& __sent)
    {
        class Cpp11CB : public ::IceInternal::Cpp11FnCallbackNC
        {
        public:

            Cpp11CB(const ::std::function<void (const ::Chat::ChatRoomPrx&)>& responseFunc, const ::std::function<void (const ::Ice::Exception&)>& exceptionFunc, const ::std::function<void (bool)>& sentFunc) :
                ::IceInternal::Cpp11FnCallbackNC(exceptionFunc, sentFunc),
                _response(responseFunc)
            {
                CallbackBase::checkCallback(true, responseFunc || exceptionFunc != nullptr);
            }

            virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
            {
                ::Chat::ChatFactoryPrx __proxy = ::Chat::ChatFactoryPrx::uncheckedCast(__result->getProxy());
                ::Chat::ChatRoomPrx __ret;
                try
                {
                    __ret = __proxy->end_getNewChatRoom(__result);
                }
                catch(::Ice::Exception& ex)
                {
                    Cpp11FnCallbackNC::__exception(__result, ex);
                    return;
                }
                if(_response != nullptr)
                {
                    _response(__ret);
                }
            }
        
        private:
            
            ::std::function<void (const ::Chat::ChatRoomPrx&)> _response;
        };
        return begin_getNewChatRoom(roomName, __ctx, new Cpp11CB(__response, __exception, __sent));
    }
    
public:
#endif

    ::Ice::AsyncResultPtr begin_getNewChatRoom(const ::std::string& roomName)
    {
        return begin_getNewChatRoom(roomName, 0, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNewChatRoom(const ::std::string& roomName, const ::Ice::Context& __ctx)
    {
        return begin_getNewChatRoom(roomName, &__ctx, ::IceInternal::__dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getNewChatRoom(const ::std::string& roomName, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNewChatRoom(roomName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNewChatRoom(const ::std::string& roomName, const ::Ice::Context& __ctx, const ::Ice::CallbackPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNewChatRoom(roomName, &__ctx, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNewChatRoom(const ::std::string& roomName, const ::Chat::Callback_ChatFactory_getNewChatRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNewChatRoom(roomName, 0, __del, __cookie);
    }

    ::Ice::AsyncResultPtr begin_getNewChatRoom(const ::std::string& roomName, const ::Ice::Context& __ctx, const ::Chat::Callback_ChatFactory_getNewChatRoomPtr& __del, const ::Ice::LocalObjectPtr& __cookie = 0)
    {
        return begin_getNewChatRoom(roomName, &__ctx, __del, __cookie);
    }

    ::Chat::ChatRoomPrx end_getNewChatRoom(const ::Ice::AsyncResultPtr&);
    
private:

    ::Chat::ChatRoomPrx getNewChatRoom(const ::std::string&, const ::Ice::Context*);
    ::Ice::AsyncResultPtr begin_getNewChatRoom(const ::std::string&, const ::Ice::Context*, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& __cookie = 0);
    
public:
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_secure(bool __secure) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_twoway() const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_oneway() const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_batchOneway() const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_datagram() const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_batchDatagram() const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_compress(bool __compress) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ChatFactory> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ChatFactory*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    static const ::std::string& ice_staticId();

private: 

    virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace Chat
{

class User : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void sendMessage(const ::std::string&, const ::Chat::ChatRoomPrx&, const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void sendPrivateMessage(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void displayMessage(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string getName(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void setName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void setPattern(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void joinRoom(const ::Chat::ChatRoomPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void exitRoom(const ::Chat::ChatRoomPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Chat::chatRoomList getRooms(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Chat::ChatRoomPrx findRoomByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string getResponseForChallenge(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class ChatServer : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void registerUser(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void login(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void enterRoom(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void exitRoom(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void logout(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual bool isLoggedIn(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Chat::chatRoomList getRooms(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Chat::ChatRoomPrx findRoomByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Chat::UserPrx findUserByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void registerChatFactory(const ::Chat::ChatFactoryPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class ChatRoom : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual void sendMessageToAll(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::std::string getName(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void setName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void enterRoom(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual void exitRoom(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Chat::userList getUsers(const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;

    virtual ::Chat::UserPrx findUserByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

class ChatFactory : virtual public ::IceDelegate::Ice::Object
{
public:

    virtual ::Chat::ChatRoomPrx getNewChatRoom(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&) = 0;
};

}

}

namespace IceDelegateM
{

namespace Chat
{

class User : virtual public ::IceDelegate::Chat::User,
             virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void sendMessage(const ::std::string&, const ::Chat::ChatRoomPrx&, const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void sendPrivateMessage(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void displayMessage(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string getName(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setPattern(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void joinRoom(const ::Chat::ChatRoomPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void exitRoom(const ::Chat::ChatRoomPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Chat::chatRoomList getRooms(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Chat::ChatRoomPrx findRoomByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string getResponseForChallenge(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class ChatServer : virtual public ::IceDelegate::Chat::ChatServer,
                   virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void registerUser(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void login(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void enterRoom(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void exitRoom(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void logout(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool isLoggedIn(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Chat::chatRoomList getRooms(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Chat::ChatRoomPrx findRoomByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Chat::UserPrx findUserByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void registerChatFactory(const ::Chat::ChatFactoryPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class ChatRoom : virtual public ::IceDelegate::Chat::ChatRoom,
                 virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual void sendMessageToAll(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string getName(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void enterRoom(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void exitRoom(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Chat::userList getUsers(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Chat::UserPrx findUserByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class ChatFactory : virtual public ::IceDelegate::Chat::ChatFactory,
                    virtual public ::IceDelegateM::Ice::Object
{
public:

    virtual ::Chat::ChatRoomPrx getNewChatRoom(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

namespace IceDelegateD
{

namespace Chat
{

class User : virtual public ::IceDelegate::Chat::User,
             virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void sendMessage(const ::std::string&, const ::Chat::ChatRoomPrx&, const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void sendPrivateMessage(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void displayMessage(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string getName(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setPattern(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void joinRoom(const ::Chat::ChatRoomPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void exitRoom(const ::Chat::ChatRoomPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Chat::chatRoomList getRooms(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Chat::ChatRoomPrx findRoomByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string getResponseForChallenge(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class ChatServer : virtual public ::IceDelegate::Chat::ChatServer,
                   virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void registerUser(const ::std::string&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void login(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void enterRoom(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void exitRoom(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void logout(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual bool isLoggedIn(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Chat::chatRoomList getRooms(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Chat::ChatRoomPrx findRoomByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Chat::UserPrx findUserByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void registerChatFactory(const ::Chat::ChatFactoryPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class ChatRoom : virtual public ::IceDelegate::Chat::ChatRoom,
                 virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual void sendMessageToAll(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::std::string getName(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void setName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void enterRoom(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual void exitRoom(const ::Chat::UserPrx&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Chat::userList getUsers(const ::Ice::Context*, ::IceInternal::InvocationObserver&);

    virtual ::Chat::UserPrx findUserByName(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

class ChatFactory : virtual public ::IceDelegate::Chat::ChatFactory,
                    virtual public ::IceDelegateD::Ice::Object
{
public:

    virtual ::Chat::ChatRoomPrx getNewChatRoom(const ::std::string&, const ::Ice::Context*, ::IceInternal::InvocationObserver&);
};

}

}

namespace Chat
{

class User : virtual public ::Ice::Object
{
public:

    typedef UserPrx ProxyType;
    typedef UserPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void sendMessage(const ::std::string&, const ::Chat::ChatRoomPrx&, const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sendMessage(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void sendPrivateMessage(const ::std::string&, const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sendPrivateMessage(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void displayMessage(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___displayMessage(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getName(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setPattern(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setPattern(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void joinRoom(const ::Chat::ChatRoomPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___joinRoom(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void exitRoom(const ::Chat::ChatRoomPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___exitRoom(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::chatRoomList getRooms(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRooms(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::ChatRoomPrx findRoomByName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___findRoomByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getResponseForChallenge(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getResponseForChallenge(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const User& l, const User& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const User& l, const User& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ChatServer : virtual public ::Ice::Object
{
public:

    typedef ChatServerPrx ProxyType;
    typedef ChatServerPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void registerUser(const ::std::string&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___registerUser(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void login(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___login(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void enterRoom(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___enterRoom(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void exitRoom(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___exitRoom(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void logout(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___logout(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual bool isLoggedIn(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___isLoggedIn(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::chatRoomList getRooms(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getRooms(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::ChatRoomPrx findRoomByName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___findRoomByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::UserPrx findUserByName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___findUserByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void registerChatFactory(const ::Chat::ChatFactoryPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___registerChatFactory(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const ChatServer& l, const ChatServer& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ChatServer& l, const ChatServer& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ChatRoom : virtual public ::Ice::Object
{
public:

    typedef ChatRoomPrx ProxyType;
    typedef ChatRoomPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void sendMessageToAll(const ::Chat::UserPrx&, const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___sendMessageToAll(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::std::string getName(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void setName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___setName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void enterRoom(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___enterRoom(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual void exitRoom(const ::Chat::UserPrx&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___exitRoom(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::userList getUsers(const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getUsers(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Chat::UserPrx findUserByName(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___findUserByName(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const ChatRoom& l, const ChatRoom& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ChatRoom& l, const ChatRoom& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ChatFactory : virtual public ::Ice::Object
{
public:

    typedef ChatFactoryPrx ProxyType;
    typedef ChatFactoryPtr PointerType;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual ::Chat::ChatRoomPrx getNewChatRoom(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) = 0;
    ::Ice::DispatchStatus ___getNewChatRoom(::IceInternal::Incoming&, const ::Ice::Current&);

    virtual ::Ice::DispatchStatus __dispatch(::IceInternal::Incoming&, const ::Ice::Current&);

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif
};

inline bool operator==(const ChatFactory& l, const ChatFactory& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ChatFactory& l, const ChatFactory& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace Chat
{

template<class T>
class CallbackNC_User_sendMessage : public Callback_User_sendMessage_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_sendMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_User_sendMessagePtr
newCallback_User_sendMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_sendMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_sendMessagePtr
newCallback_User_sendMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_sendMessage<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_User_sendMessagePtr
newCallback_User_sendMessage(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_sendMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_sendMessagePtr
newCallback_User_sendMessage(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_sendMessage<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_sendMessage : public Callback_User_sendMessage_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_sendMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_User_sendMessagePtr
newCallback_User_sendMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_sendMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_sendMessagePtr
newCallback_User_sendMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_sendMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_User_sendMessagePtr
newCallback_User_sendMessage(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_sendMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_sendMessagePtr
newCallback_User_sendMessage(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_sendMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_User_sendPrivateMessage : public Callback_User_sendPrivateMessage_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_sendPrivateMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_User_sendPrivateMessagePtr
newCallback_User_sendPrivateMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_sendPrivateMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_sendPrivateMessagePtr
newCallback_User_sendPrivateMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_sendPrivateMessage<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_User_sendPrivateMessagePtr
newCallback_User_sendPrivateMessage(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_sendPrivateMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_sendPrivateMessagePtr
newCallback_User_sendPrivateMessage(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_sendPrivateMessage<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_sendPrivateMessage : public Callback_User_sendPrivateMessage_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_sendPrivateMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_User_sendPrivateMessagePtr
newCallback_User_sendPrivateMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_sendPrivateMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_sendPrivateMessagePtr
newCallback_User_sendPrivateMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_sendPrivateMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_User_sendPrivateMessagePtr
newCallback_User_sendPrivateMessage(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_sendPrivateMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_sendPrivateMessagePtr
newCallback_User_sendPrivateMessage(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_sendPrivateMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_User_displayMessage : public Callback_User_displayMessage_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_displayMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_User_displayMessagePtr
newCallback_User_displayMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_displayMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_displayMessagePtr
newCallback_User_displayMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_displayMessage<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_User_displayMessagePtr
newCallback_User_displayMessage(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_displayMessage<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_displayMessagePtr
newCallback_User_displayMessage(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_displayMessage<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_displayMessage : public Callback_User_displayMessage_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_displayMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_User_displayMessagePtr
newCallback_User_displayMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_displayMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_displayMessagePtr
newCallback_User_displayMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_displayMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_User_displayMessagePtr
newCallback_User_displayMessage(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_displayMessage<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_displayMessagePtr
newCallback_User_displayMessage(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_displayMessage<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_User_getName : public Callback_User_getName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_User_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_User_getNamePtr
newCallback_User_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_getName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_getNamePtr
newCallback_User_getName(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_getName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_getName : public Callback_User_getName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_User_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_User_getNamePtr
newCallback_User_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_getName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_getNamePtr
newCallback_User_getName(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_getName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_User_setName : public Callback_User_setName_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_setName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_User_setNamePtr
newCallback_User_setName(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_setName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_setNamePtr
newCallback_User_setName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_setName<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_User_setNamePtr
newCallback_User_setName(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_setName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_setNamePtr
newCallback_User_setName(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_setName<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_setName : public Callback_User_setName_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_setName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_User_setNamePtr
newCallback_User_setName(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_setName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_setNamePtr
newCallback_User_setName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_setName<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_User_setNamePtr
newCallback_User_setName(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_setName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_setNamePtr
newCallback_User_setName(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_setName<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_User_setPattern : public Callback_User_setPattern_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_setPattern(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_User_setPatternPtr
newCallback_User_setPattern(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_setPattern<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_setPatternPtr
newCallback_User_setPattern(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_setPattern<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_User_setPatternPtr
newCallback_User_setPattern(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_setPattern<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_setPatternPtr
newCallback_User_setPattern(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_setPattern<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_setPattern : public Callback_User_setPattern_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_setPattern(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_User_setPatternPtr
newCallback_User_setPattern(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_setPattern<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_setPatternPtr
newCallback_User_setPattern(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_setPattern<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_User_setPatternPtr
newCallback_User_setPattern(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_setPattern<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_setPatternPtr
newCallback_User_setPattern(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_setPattern<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_User_joinRoom : public Callback_User_joinRoom_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_joinRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_User_joinRoomPtr
newCallback_User_joinRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_joinRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_joinRoomPtr
newCallback_User_joinRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_joinRoom<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_User_joinRoomPtr
newCallback_User_joinRoom(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_joinRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_joinRoomPtr
newCallback_User_joinRoom(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_joinRoom<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_joinRoom : public Callback_User_joinRoom_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_joinRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_User_joinRoomPtr
newCallback_User_joinRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_joinRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_joinRoomPtr
newCallback_User_joinRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_joinRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_User_joinRoomPtr
newCallback_User_joinRoom(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_joinRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_joinRoomPtr
newCallback_User_joinRoom(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_joinRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_User_exitRoom : public Callback_User_exitRoom_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_User_exitRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_User_exitRoomPtr
newCallback_User_exitRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_exitRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_exitRoomPtr
newCallback_User_exitRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_exitRoom<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_User_exitRoomPtr
newCallback_User_exitRoom(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_exitRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_exitRoomPtr
newCallback_User_exitRoom(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_exitRoom<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_exitRoom : public Callback_User_exitRoom_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_User_exitRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_User_exitRoomPtr
newCallback_User_exitRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_exitRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_exitRoomPtr
newCallback_User_exitRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_exitRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_User_exitRoomPtr
newCallback_User_exitRoom(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_exitRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_exitRoomPtr
newCallback_User_exitRoom(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_exitRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_User_getRooms : public Callback_User_getRooms_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::chatRoomList&);

    CallbackNC_User_getRooms(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
        ::Chat::chatRoomList __ret;
        try
        {
            __ret = __proxy->end_getRooms(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_User_getRoomsPtr
newCallback_User_getRooms(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::chatRoomList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_getRooms<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_getRoomsPtr
newCallback_User_getRooms(T* instance, void (T::*cb)(const ::Chat::chatRoomList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_getRooms<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_getRooms : public Callback_User_getRooms_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::chatRoomList&, const CT&);

    Callback_User_getRooms(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
        ::Chat::chatRoomList __ret;
        try
        {
            __ret = __proxy->end_getRooms(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_User_getRoomsPtr
newCallback_User_getRooms(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::chatRoomList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_getRooms<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_getRoomsPtr
newCallback_User_getRooms(T* instance, void (T::*cb)(const ::Chat::chatRoomList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_getRooms<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_User_findRoomByName : public Callback_User_findRoomByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::ChatRoomPrx&);

    CallbackNC_User_findRoomByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
        ::Chat::ChatRoomPrx __ret;
        try
        {
            __ret = __proxy->end_findRoomByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_User_findRoomByNamePtr
newCallback_User_findRoomByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::ChatRoomPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_findRoomByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_findRoomByNamePtr
newCallback_User_findRoomByName(T* instance, void (T::*cb)(const ::Chat::ChatRoomPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_findRoomByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_findRoomByName : public Callback_User_findRoomByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::ChatRoomPrx&, const CT&);

    Callback_User_findRoomByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
        ::Chat::ChatRoomPrx __ret;
        try
        {
            __ret = __proxy->end_findRoomByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_User_findRoomByNamePtr
newCallback_User_findRoomByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::ChatRoomPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_findRoomByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_findRoomByNamePtr
newCallback_User_findRoomByName(T* instance, void (T::*cb)(const ::Chat::ChatRoomPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_findRoomByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_User_getResponseForChallenge : public Callback_User_getResponseForChallenge_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_User_getResponseForChallenge(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getResponseForChallenge(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_User_getResponseForChallengePtr
newCallback_User_getResponseForChallenge(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_getResponseForChallenge<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_User_getResponseForChallengePtr
newCallback_User_getResponseForChallenge(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_User_getResponseForChallenge<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_User_getResponseForChallenge : public Callback_User_getResponseForChallenge_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_User_getResponseForChallenge(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::UserPrx __proxy = ::Chat::UserPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getResponseForChallenge(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_User_getResponseForChallengePtr
newCallback_User_getResponseForChallenge(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_getResponseForChallenge<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_User_getResponseForChallengePtr
newCallback_User_getResponseForChallenge(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_User_getResponseForChallenge<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_registerUser : public Callback_ChatServer_registerUser_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_registerUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_registerUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_ChatServer_registerUserPtr
newCallback_ChatServer_registerUser(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_registerUserPtr
newCallback_ChatServer_registerUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerUser<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_registerUserPtr
newCallback_ChatServer_registerUser(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerUser<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_registerUserPtr
newCallback_ChatServer_registerUser(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerUser<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_registerUser : public Callback_ChatServer_registerUser_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_registerUser(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_registerUser(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatServer_registerUserPtr
newCallback_ChatServer_registerUser(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_registerUserPtr
newCallback_ChatServer_registerUser(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerUser<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_registerUserPtr
newCallback_ChatServer_registerUser(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerUser<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_registerUserPtr
newCallback_ChatServer_registerUser(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerUser<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_login : public Callback_ChatServer_login_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_login(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_login(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_ChatServer_loginPtr
newCallback_ChatServer_login(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_login<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_loginPtr
newCallback_ChatServer_login(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_login<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_loginPtr
newCallback_ChatServer_login(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_login<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_loginPtr
newCallback_ChatServer_login(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_login<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_login : public Callback_ChatServer_login_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_login(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_login(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatServer_loginPtr
newCallback_ChatServer_login(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_login<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_loginPtr
newCallback_ChatServer_login(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_login<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_loginPtr
newCallback_ChatServer_login(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_login<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_loginPtr
newCallback_ChatServer_login(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_login<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_enterRoom : public Callback_ChatServer_enterRoom_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_enterRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_enterRoom(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)();
        }
    }

    Response response;
};

template<class T> Callback_ChatServer_enterRoomPtr
newCallback_ChatServer_enterRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_enterRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_enterRoomPtr
newCallback_ChatServer_enterRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_enterRoom<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_enterRoomPtr
newCallback_ChatServer_enterRoom(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_enterRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_enterRoomPtr
newCallback_ChatServer_enterRoom(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_enterRoom<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_enterRoom : public Callback_ChatServer_enterRoom_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_enterRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        try
        {
            __proxy->end_enterRoom(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatServer_enterRoomPtr
newCallback_ChatServer_enterRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_enterRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_enterRoomPtr
newCallback_ChatServer_enterRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_enterRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_enterRoomPtr
newCallback_ChatServer_enterRoom(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_enterRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_enterRoomPtr
newCallback_ChatServer_enterRoom(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_enterRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_exitRoom : public Callback_ChatServer_exitRoom_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_exitRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ChatServer_exitRoomPtr
newCallback_ChatServer_exitRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_exitRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_exitRoomPtr
newCallback_ChatServer_exitRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_exitRoom<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_exitRoomPtr
newCallback_ChatServer_exitRoom(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_exitRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_exitRoomPtr
newCallback_ChatServer_exitRoom(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_exitRoom<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_exitRoom : public Callback_ChatServer_exitRoom_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_exitRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ChatServer_exitRoomPtr
newCallback_ChatServer_exitRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_exitRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_exitRoomPtr
newCallback_ChatServer_exitRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_exitRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_exitRoomPtr
newCallback_ChatServer_exitRoom(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_exitRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_exitRoomPtr
newCallback_ChatServer_exitRoom(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_exitRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_logout : public Callback_ChatServer_logout_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_logout(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ChatServer_logoutPtr
newCallback_ChatServer_logout(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_logout<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_logoutPtr
newCallback_ChatServer_logout(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_logout<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_logoutPtr
newCallback_ChatServer_logout(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_logout<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_logoutPtr
newCallback_ChatServer_logout(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_logout<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_logout : public Callback_ChatServer_logout_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_logout(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ChatServer_logoutPtr
newCallback_ChatServer_logout(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_logout<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_logoutPtr
newCallback_ChatServer_logout(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_logout<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_logoutPtr
newCallback_ChatServer_logout(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_logout<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_logoutPtr
newCallback_ChatServer_logout(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_logout<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_isLoggedIn : public Callback_ChatServer_isLoggedIn_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ChatServer_isLoggedIn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isLoggedIn(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ChatServer_isLoggedInPtr
newCallback_ChatServer_isLoggedIn(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_isLoggedIn<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_isLoggedInPtr
newCallback_ChatServer_isLoggedIn(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_isLoggedIn<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_isLoggedIn : public Callback_ChatServer_isLoggedIn_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ChatServer_isLoggedIn(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        bool __ret;
        try
        {
            __ret = __proxy->end_isLoggedIn(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatServer_isLoggedInPtr
newCallback_ChatServer_isLoggedIn(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_isLoggedIn<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_isLoggedInPtr
newCallback_ChatServer_isLoggedIn(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_isLoggedIn<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_getRooms : public Callback_ChatServer_getRooms_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::chatRoomList&);

    CallbackNC_ChatServer_getRooms(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::chatRoomList __ret;
        try
        {
            __ret = __proxy->end_getRooms(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ChatServer_getRoomsPtr
newCallback_ChatServer_getRooms(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::chatRoomList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_getRooms<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_getRoomsPtr
newCallback_ChatServer_getRooms(T* instance, void (T::*cb)(const ::Chat::chatRoomList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_getRooms<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_getRooms : public Callback_ChatServer_getRooms_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::chatRoomList&, const CT&);

    Callback_ChatServer_getRooms(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::chatRoomList __ret;
        try
        {
            __ret = __proxy->end_getRooms(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatServer_getRoomsPtr
newCallback_ChatServer_getRooms(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::chatRoomList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_getRooms<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_getRoomsPtr
newCallback_ChatServer_getRooms(T* instance, void (T::*cb)(const ::Chat::chatRoomList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_getRooms<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_findRoomByName : public Callback_ChatServer_findRoomByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::ChatRoomPrx&);

    CallbackNC_ChatServer_findRoomByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::ChatRoomPrx __ret;
        try
        {
            __ret = __proxy->end_findRoomByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ChatServer_findRoomByNamePtr
newCallback_ChatServer_findRoomByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::ChatRoomPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_findRoomByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_findRoomByNamePtr
newCallback_ChatServer_findRoomByName(T* instance, void (T::*cb)(const ::Chat::ChatRoomPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_findRoomByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_findRoomByName : public Callback_ChatServer_findRoomByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::ChatRoomPrx&, const CT&);

    Callback_ChatServer_findRoomByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::ChatRoomPrx __ret;
        try
        {
            __ret = __proxy->end_findRoomByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatServer_findRoomByNamePtr
newCallback_ChatServer_findRoomByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::ChatRoomPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_findRoomByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_findRoomByNamePtr
newCallback_ChatServer_findRoomByName(T* instance, void (T::*cb)(const ::Chat::ChatRoomPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_findRoomByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_findUserByName : public Callback_ChatServer_findUserByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::UserPrx&);

    CallbackNC_ChatServer_findUserByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::UserPrx __ret;
        try
        {
            __ret = __proxy->end_findUserByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ChatServer_findUserByNamePtr
newCallback_ChatServer_findUserByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::UserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_findUserByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_findUserByNamePtr
newCallback_ChatServer_findUserByName(T* instance, void (T::*cb)(const ::Chat::UserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_findUserByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_findUserByName : public Callback_ChatServer_findUserByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::UserPrx&, const CT&);

    Callback_ChatServer_findUserByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatServerPrx __proxy = ::Chat::ChatServerPrx::uncheckedCast(__result->getProxy());
        ::Chat::UserPrx __ret;
        try
        {
            __ret = __proxy->end_findUserByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatServer_findUserByNamePtr
newCallback_ChatServer_findUserByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::UserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_findUserByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_findUserByNamePtr
newCallback_ChatServer_findUserByName(T* instance, void (T::*cb)(const ::Chat::UserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_findUserByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatServer_registerChatFactory : public Callback_ChatServer_registerChatFactory_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatServer_registerChatFactory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ChatServer_registerChatFactoryPtr
newCallback_ChatServer_registerChatFactory(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerChatFactory<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_registerChatFactoryPtr
newCallback_ChatServer_registerChatFactory(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerChatFactory<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatServer_registerChatFactoryPtr
newCallback_ChatServer_registerChatFactory(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerChatFactory<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatServer_registerChatFactoryPtr
newCallback_ChatServer_registerChatFactory(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatServer_registerChatFactory<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatServer_registerChatFactory : public Callback_ChatServer_registerChatFactory_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatServer_registerChatFactory(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ChatServer_registerChatFactoryPtr
newCallback_ChatServer_registerChatFactory(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerChatFactory<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_registerChatFactoryPtr
newCallback_ChatServer_registerChatFactory(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerChatFactory<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_registerChatFactoryPtr
newCallback_ChatServer_registerChatFactory(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerChatFactory<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatServer_registerChatFactoryPtr
newCallback_ChatServer_registerChatFactory(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatServer_registerChatFactory<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatRoom_sendMessageToAll : public Callback_ChatRoom_sendMessageToAll_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatRoom_sendMessageToAll(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ChatRoom_sendMessageToAllPtr
newCallback_ChatRoom_sendMessageToAll(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_sendMessageToAll<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatRoom_sendMessageToAllPtr
newCallback_ChatRoom_sendMessageToAll(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_sendMessageToAll<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatRoom_sendMessageToAllPtr
newCallback_ChatRoom_sendMessageToAll(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_sendMessageToAll<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatRoom_sendMessageToAllPtr
newCallback_ChatRoom_sendMessageToAll(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_sendMessageToAll<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatRoom_sendMessageToAll : public Callback_ChatRoom_sendMessageToAll_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatRoom_sendMessageToAll(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ChatRoom_sendMessageToAllPtr
newCallback_ChatRoom_sendMessageToAll(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_sendMessageToAll<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_sendMessageToAllPtr
newCallback_ChatRoom_sendMessageToAll(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_sendMessageToAll<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_sendMessageToAllPtr
newCallback_ChatRoom_sendMessageToAll(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_sendMessageToAll<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_sendMessageToAllPtr
newCallback_ChatRoom_sendMessageToAll(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_sendMessageToAll<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatRoom_getName : public Callback_ChatRoom_getName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_ChatRoom_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatRoomPrx __proxy = ::Chat::ChatRoomPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ChatRoom_getNamePtr
newCallback_ChatRoom_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_getName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatRoom_getNamePtr
newCallback_ChatRoom_getName(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_getName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatRoom_getName : public Callback_ChatRoom_getName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_ChatRoom_getName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatRoomPrx __proxy = ::Chat::ChatRoomPrx::uncheckedCast(__result->getProxy());
        ::std::string __ret;
        try
        {
            __ret = __proxy->end_getName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatRoom_getNamePtr
newCallback_ChatRoom_getName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_getName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_getNamePtr
newCallback_ChatRoom_getName(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_getName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatRoom_setName : public Callback_ChatRoom_setName_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatRoom_setName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ChatRoom_setNamePtr
newCallback_ChatRoom_setName(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_setName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatRoom_setNamePtr
newCallback_ChatRoom_setName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_setName<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatRoom_setNamePtr
newCallback_ChatRoom_setName(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_setName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatRoom_setNamePtr
newCallback_ChatRoom_setName(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_setName<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatRoom_setName : public Callback_ChatRoom_setName_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatRoom_setName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ChatRoom_setNamePtr
newCallback_ChatRoom_setName(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_setName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_setNamePtr
newCallback_ChatRoom_setName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_setName<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_setNamePtr
newCallback_ChatRoom_setName(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_setName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_setNamePtr
newCallback_ChatRoom_setName(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_setName<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatRoom_enterRoom : public Callback_ChatRoom_enterRoom_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatRoom_enterRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ChatRoom_enterRoomPtr
newCallback_ChatRoom_enterRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_enterRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatRoom_enterRoomPtr
newCallback_ChatRoom_enterRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_enterRoom<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatRoom_enterRoomPtr
newCallback_ChatRoom_enterRoom(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_enterRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatRoom_enterRoomPtr
newCallback_ChatRoom_enterRoom(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_enterRoom<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatRoom_enterRoom : public Callback_ChatRoom_enterRoom_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatRoom_enterRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ChatRoom_enterRoomPtr
newCallback_ChatRoom_enterRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_enterRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_enterRoomPtr
newCallback_ChatRoom_enterRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_enterRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_enterRoomPtr
newCallback_ChatRoom_enterRoom(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_enterRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_enterRoomPtr
newCallback_ChatRoom_enterRoom(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_enterRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatRoom_exitRoom : public Callback_ChatRoom_exitRoom_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ChatRoom_exitRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

template<class T> Callback_ChatRoom_exitRoomPtr
newCallback_ChatRoom_exitRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_exitRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatRoom_exitRoomPtr
newCallback_ChatRoom_exitRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_exitRoom<T>(instance, 0, excb, sentcb);
}

template<class T> Callback_ChatRoom_exitRoomPtr
newCallback_ChatRoom_exitRoom(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_exitRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatRoom_exitRoomPtr
newCallback_ChatRoom_exitRoom(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_exitRoom<T>(instance, 0, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatRoom_exitRoom : public Callback_ChatRoom_exitRoom_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ChatRoom_exitRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

template<class T, typename CT> Callback_ChatRoom_exitRoomPtr
newCallback_ChatRoom_exitRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_exitRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_exitRoomPtr
newCallback_ChatRoom_exitRoom(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_exitRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_exitRoomPtr
newCallback_ChatRoom_exitRoom(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_exitRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_exitRoomPtr
newCallback_ChatRoom_exitRoom(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_exitRoom<T, CT>(instance, 0, excb, sentcb);
}

template<class T>
class CallbackNC_ChatRoom_getUsers : public Callback_ChatRoom_getUsers_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::userList&);

    CallbackNC_ChatRoom_getUsers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatRoomPrx __proxy = ::Chat::ChatRoomPrx::uncheckedCast(__result->getProxy());
        ::Chat::userList __ret;
        try
        {
            __ret = __proxy->end_getUsers(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ChatRoom_getUsersPtr
newCallback_ChatRoom_getUsers(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::userList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_getUsers<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatRoom_getUsersPtr
newCallback_ChatRoom_getUsers(T* instance, void (T::*cb)(const ::Chat::userList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_getUsers<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatRoom_getUsers : public Callback_ChatRoom_getUsers_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::userList&, const CT&);

    Callback_ChatRoom_getUsers(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatRoomPrx __proxy = ::Chat::ChatRoomPrx::uncheckedCast(__result->getProxy());
        ::Chat::userList __ret;
        try
        {
            __ret = __proxy->end_getUsers(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatRoom_getUsersPtr
newCallback_ChatRoom_getUsers(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::userList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_getUsers<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_getUsersPtr
newCallback_ChatRoom_getUsers(T* instance, void (T::*cb)(const ::Chat::userList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_getUsers<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatRoom_findUserByName : public Callback_ChatRoom_findUserByName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::UserPrx&);

    CallbackNC_ChatRoom_findUserByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatRoomPrx __proxy = ::Chat::ChatRoomPrx::uncheckedCast(__result->getProxy());
        ::Chat::UserPrx __ret;
        try
        {
            __ret = __proxy->end_findUserByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ChatRoom_findUserByNamePtr
newCallback_ChatRoom_findUserByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::UserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_findUserByName<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatRoom_findUserByNamePtr
newCallback_ChatRoom_findUserByName(T* instance, void (T::*cb)(const ::Chat::UserPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatRoom_findUserByName<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatRoom_findUserByName : public Callback_ChatRoom_findUserByName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::UserPrx&, const CT&);

    Callback_ChatRoom_findUserByName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatRoomPrx __proxy = ::Chat::ChatRoomPrx::uncheckedCast(__result->getProxy());
        ::Chat::UserPrx __ret;
        try
        {
            __ret = __proxy->end_findUserByName(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatRoom_findUserByNamePtr
newCallback_ChatRoom_findUserByName(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::UserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_findUserByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatRoom_findUserByNamePtr
newCallback_ChatRoom_findUserByName(T* instance, void (T::*cb)(const ::Chat::UserPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatRoom_findUserByName<T, CT>(instance, cb, excb, sentcb);
}

template<class T>
class CallbackNC_ChatFactory_getNewChatRoom : public Callback_ChatFactory_getNewChatRoom_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::Chat::ChatRoomPrx&);

    CallbackNC_ChatFactory_getNewChatRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatFactoryPrx __proxy = ::Chat::ChatFactoryPrx::uncheckedCast(__result->getProxy());
        ::Chat::ChatRoomPrx __ret;
        try
        {
            __ret = __proxy->end_getNewChatRoom(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::CallbackNC<T>::callback.get()->*response)(__ret);
        }
    }

    Response response;
};

template<class T> Callback_ChatFactory_getNewChatRoomPtr
newCallback_ChatFactory_getNewChatRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::ChatRoomPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatFactory_getNewChatRoom<T>(instance, cb, excb, sentcb);
}

template<class T> Callback_ChatFactory_getNewChatRoomPtr
newCallback_ChatFactory_getNewChatRoom(T* instance, void (T::*cb)(const ::Chat::ChatRoomPrx&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ChatFactory_getNewChatRoom<T>(instance, cb, excb, sentcb);
}

template<class T, typename CT>
class Callback_ChatFactory_getNewChatRoom : public Callback_ChatFactory_getNewChatRoom_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::Chat::ChatRoomPrx&, const CT&);

    Callback_ChatFactory_getNewChatRoom(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), response(cb)
    {
    }

    virtual void __completed(const ::Ice::AsyncResultPtr& __result) const
    {
        ::Chat::ChatFactoryPrx __proxy = ::Chat::ChatFactoryPrx::uncheckedCast(__result->getProxy());
        ::Chat::ChatRoomPrx __ret;
        try
        {
            __ret = __proxy->end_getNewChatRoom(__result);
        }
        catch(::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::__exception(__result, ex);
            return;
        }
        if(response)
        {
            (::IceInternal::Callback<T, CT>::callback.get()->*response)(__ret, CT::dynamicCast(__result->getCookie()));
        }
    }

    Response response;
};

template<class T, typename CT> Callback_ChatFactory_getNewChatRoomPtr
newCallback_ChatFactory_getNewChatRoom(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::Chat::ChatRoomPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatFactory_getNewChatRoom<T, CT>(instance, cb, excb, sentcb);
}

template<class T, typename CT> Callback_ChatFactory_getNewChatRoomPtr
newCallback_ChatFactory_getNewChatRoom(T* instance, void (T::*cb)(const ::Chat::ChatRoomPrx&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ChatFactory_getNewChatRoom<T, CT>(instance, cb, excb, sentcb);
}

}

#endif
