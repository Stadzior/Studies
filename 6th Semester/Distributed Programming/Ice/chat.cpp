// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `chat.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include <chat.h>
#include <Ice/LocalException.h>
#include <Ice/ObjectFactory.h>
#include <Ice/BasicStream.h>
#include <Ice/Object.h>
#include <IceUtil/Iterator.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

namespace
{

const ::std::string __Chat__User__sendMessage_name = "sendMessage";

const ::std::string __Chat__User__sendPrivateMessage_name = "sendPrivateMessage";

const ::std::string __Chat__User__displayMessage_name = "displayMessage";

const ::std::string __Chat__User__getName_name = "getName";

const ::std::string __Chat__User__setName_name = "setName";

const ::std::string __Chat__User__setPattern_name = "setPattern";

const ::std::string __Chat__User__joinRoom_name = "joinRoom";

const ::std::string __Chat__User__exitRoom_name = "exitRoom";

const ::std::string __Chat__User__getRooms_name = "getRooms";

const ::std::string __Chat__User__findRoomByName_name = "findRoomByName";

const ::std::string __Chat__User__getResponseForChallenge_name = "getResponseForChallenge";

const ::std::string __Chat__ChatServer__registerUser_name = "registerUser";

const ::std::string __Chat__ChatServer__login_name = "login";

const ::std::string __Chat__ChatServer__enterRoom_name = "enterRoom";

const ::std::string __Chat__ChatServer__exitRoom_name = "exitRoom";

const ::std::string __Chat__ChatServer__logout_name = "logout";

const ::std::string __Chat__ChatServer__isLoggedIn_name = "isLoggedIn";

const ::std::string __Chat__ChatServer__getRooms_name = "getRooms";

const ::std::string __Chat__ChatServer__findRoomByName_name = "findRoomByName";

const ::std::string __Chat__ChatServer__findUserByName_name = "findUserByName";

const ::std::string __Chat__ChatServer__registerChatFactory_name = "registerChatFactory";

const ::std::string __Chat__ChatRoom__sendMessageToAll_name = "sendMessageToAll";

const ::std::string __Chat__ChatRoom__getName_name = "getName";

const ::std::string __Chat__ChatRoom__setName_name = "setName";

const ::std::string __Chat__ChatRoom__enterRoom_name = "enterRoom";

const ::std::string __Chat__ChatRoom__exitRoom_name = "exitRoom";

const ::std::string __Chat__ChatRoom__getUsers_name = "getUsers";

const ::std::string __Chat__ChatRoom__findUserByName_name = "findUserByName";

const ::std::string __Chat__ChatFactory__getNewChatRoom_name = "getNewChatRoom";

}

namespace
{

const char* __Chat__UserNotFound_name = "Chat::UserNotFound";

struct __F__Chat__UserNotFound : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Chat::UserNotFound();
    }
};

class __F__Chat__UserNotFound__Init
{
public:

    __F__Chat__UserNotFound__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Chat::UserNotFound", new __F__Chat__UserNotFound);
    }

    ~__F__Chat__UserNotFound__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Chat::UserNotFound");
    }
};

const __F__Chat__UserNotFound__Init __F__Chat__UserNotFound__i;

}

Chat::UserNotFound::~UserNotFound() throw()
{
}

::std::string
Chat::UserNotFound::ice_name() const
{
    return __Chat__UserNotFound_name;
}

Chat::UserNotFound*
Chat::UserNotFound::ice_clone() const
{
    return new UserNotFound(*this);
}

void
Chat::UserNotFound::ice_throw() const
{
    throw *this;
}

void
Chat::UserNotFound::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Chat::UserNotFound", -1, true);
    __os->endWriteSlice();
}

void
Chat::UserNotFound::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

const char* __Chat__AuthenticationError_name = "Chat::AuthenticationError";

struct __F__Chat__AuthenticationError : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Chat::AuthenticationError();
    }
};

class __F__Chat__AuthenticationError__Init
{
public:

    __F__Chat__AuthenticationError__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Chat::AuthenticationError", new __F__Chat__AuthenticationError);
    }

    ~__F__Chat__AuthenticationError__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Chat::AuthenticationError");
    }
};

const __F__Chat__AuthenticationError__Init __F__Chat__AuthenticationError__i;

}

Chat::AuthenticationError::~AuthenticationError() throw()
{
}

::std::string
Chat::AuthenticationError::ice_name() const
{
    return __Chat__AuthenticationError_name;
}

Chat::AuthenticationError*
Chat::AuthenticationError::ice_clone() const
{
    return new AuthenticationError(*this);
}

void
Chat::AuthenticationError::ice_throw() const
{
    throw *this;
}

void
Chat::AuthenticationError::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Chat::AuthenticationError", -1, true);
    __os->endWriteSlice();
}

void
Chat::AuthenticationError::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

const char* __Chat__EmptyUsername_name = "Chat::EmptyUsername";

struct __F__Chat__EmptyUsername : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Chat::EmptyUsername();
    }
};

class __F__Chat__EmptyUsername__Init
{
public:

    __F__Chat__EmptyUsername__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Chat::EmptyUsername", new __F__Chat__EmptyUsername);
    }

    ~__F__Chat__EmptyUsername__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Chat::EmptyUsername");
    }
};

const __F__Chat__EmptyUsername__Init __F__Chat__EmptyUsername__i;

}

Chat::EmptyUsername::~EmptyUsername() throw()
{
}

::std::string
Chat::EmptyUsername::ice_name() const
{
    return __Chat__EmptyUsername_name;
}

Chat::EmptyUsername*
Chat::EmptyUsername::ice_clone() const
{
    return new EmptyUsername(*this);
}

void
Chat::EmptyUsername::ice_throw() const
{
    throw *this;
}

void
Chat::EmptyUsername::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Chat::EmptyUsername", -1, true);
    __os->endWriteSlice();
}

void
Chat::EmptyUsername::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

const char* __Chat__RoomNotFound_name = "Chat::RoomNotFound";

struct __F__Chat__RoomNotFound : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Chat::RoomNotFound();
    }
};

class __F__Chat__RoomNotFound__Init
{
public:

    __F__Chat__RoomNotFound__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Chat::RoomNotFound", new __F__Chat__RoomNotFound);
    }

    ~__F__Chat__RoomNotFound__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Chat::RoomNotFound");
    }
};

const __F__Chat__RoomNotFound__Init __F__Chat__RoomNotFound__i;

}

Chat::RoomNotFound::~RoomNotFound() throw()
{
}

::std::string
Chat::RoomNotFound::ice_name() const
{
    return __Chat__RoomNotFound_name;
}

Chat::RoomNotFound*
Chat::RoomNotFound::ice_clone() const
{
    return new RoomNotFound(*this);
}

void
Chat::RoomNotFound::ice_throw() const
{
    throw *this;
}

void
Chat::RoomNotFound::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Chat::RoomNotFound", -1, true);
    __os->endWriteSlice();
}

void
Chat::RoomNotFound::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

const char* __Chat__UserAlreadyRegistered_name = "Chat::UserAlreadyRegistered";

struct __F__Chat__UserAlreadyRegistered : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Chat::UserAlreadyRegistered();
    }
};

class __F__Chat__UserAlreadyRegistered__Init
{
public:

    __F__Chat__UserAlreadyRegistered__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Chat::UserAlreadyRegistered", new __F__Chat__UserAlreadyRegistered);
    }

    ~__F__Chat__UserAlreadyRegistered__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Chat::UserAlreadyRegistered");
    }
};

const __F__Chat__UserAlreadyRegistered__Init __F__Chat__UserAlreadyRegistered__i;

}

Chat::UserAlreadyRegistered::~UserAlreadyRegistered() throw()
{
}

::std::string
Chat::UserAlreadyRegistered::ice_name() const
{
    return __Chat__UserAlreadyRegistered_name;
}

Chat::UserAlreadyRegistered*
Chat::UserAlreadyRegistered::ice_clone() const
{
    return new UserAlreadyRegistered(*this);
}

void
Chat::UserAlreadyRegistered::ice_throw() const
{
    throw *this;
}

void
Chat::UserAlreadyRegistered::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Chat::UserAlreadyRegistered", -1, true);
    __os->endWriteSlice();
}

void
Chat::UserAlreadyRegistered::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace
{

const char* __Chat__FactoryNotRegistered_name = "Chat::FactoryNotRegistered";

struct __F__Chat__FactoryNotRegistered : public ::IceInternal::UserExceptionFactory
{
    virtual void
    createAndThrow(const ::std::string&)
    {
        throw ::Chat::FactoryNotRegistered();
    }
};

class __F__Chat__FactoryNotRegistered__Init
{
public:

    __F__Chat__FactoryNotRegistered__Init()
    {
        ::IceInternal::factoryTable->addExceptionFactory("::Chat::FactoryNotRegistered", new __F__Chat__FactoryNotRegistered);
    }

    ~__F__Chat__FactoryNotRegistered__Init()
    {
        ::IceInternal::factoryTable->removeExceptionFactory("::Chat::FactoryNotRegistered");
    }
};

const __F__Chat__FactoryNotRegistered__Init __F__Chat__FactoryNotRegistered__i;

}

Chat::FactoryNotRegistered::~FactoryNotRegistered() throw()
{
}

::std::string
Chat::FactoryNotRegistered::ice_name() const
{
    return __Chat__FactoryNotRegistered_name;
}

Chat::FactoryNotRegistered*
Chat::FactoryNotRegistered::ice_clone() const
{
    return new FactoryNotRegistered(*this);
}

void
Chat::FactoryNotRegistered::ice_throw() const
{
    throw *this;
}

void
Chat::FactoryNotRegistered::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice("::Chat::FactoryNotRegistered", -1, true);
    __os->endWriteSlice();
}

void
Chat::FactoryNotRegistered::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

namespace Ice
{
}
::IceProxy::Ice::Object* ::IceProxy::Chat::upCast(::IceProxy::Chat::User* p) { return p; }

void
::IceProxy::Chat::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Chat::User>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Chat::User;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Chat::User::sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__User__sendMessage_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::User* __del = dynamic_cast< ::IceDelegate::Chat::User*>(__delBase.get());
            __del->sendMessage(message, room, who, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::User::begin_sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__User__sendMessage_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__User__sendMessage_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(message);
        __os->write(room);
        __os->write(who);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::User::end_sendMessage(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Chat__User__sendMessage_name);
}

void
IceProxy::Chat::User::sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__User__sendPrivateMessage_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::User* __del = dynamic_cast< ::IceDelegate::Chat::User*>(__delBase.get());
            __del->sendPrivateMessage(message, who, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::User::begin_sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__User__sendPrivateMessage_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__User__sendPrivateMessage_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(message);
        __os->write(who);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::User::end_sendPrivateMessage(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Chat__User__sendPrivateMessage_name);
}

void
IceProxy::Chat::User::displayMessage(const ::std::string& message, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__User__displayMessage_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::User* __del = dynamic_cast< ::IceDelegate::Chat::User*>(__delBase.get());
            __del->displayMessage(message, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::User::begin_displayMessage(const ::std::string& message, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__User__displayMessage_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__User__displayMessage_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(message);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::User::end_displayMessage(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Chat__User__displayMessage_name);
}

::std::string
IceProxy::Chat::User::getName(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__User__getName_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__User__getName_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::User* __del = dynamic_cast< ::IceDelegate::Chat::User*>(__delBase.get());
            return __del->getName(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::User::begin_getName(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__User__getName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__User__getName_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__User__getName_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::Chat::User::end_getName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__User__getName_name);
    ::std::string __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Chat::User::setName(const ::std::string& name, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__User__setName_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::User* __del = dynamic_cast< ::IceDelegate::Chat::User*>(__delBase.get());
            __del->setName(name, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::User::begin_setName(const ::std::string& name, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__User__setName_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__User__setName_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::User::end_setName(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Chat__User__setName_name);
}

void
IceProxy::Chat::User::setPattern(const ::std::string& pattern, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__User__setPattern_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::User* __del = dynamic_cast< ::IceDelegate::Chat::User*>(__delBase.get());
            __del->setPattern(pattern, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::User::begin_setPattern(const ::std::string& pattern, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__User__setPattern_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__User__setPattern_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(pattern);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::User::end_setPattern(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Chat__User__setPattern_name);
}

void
IceProxy::Chat::User::joinRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__User__joinRoom_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::User* __del = dynamic_cast< ::IceDelegate::Chat::User*>(__delBase.get());
            __del->joinRoom(room, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::User::begin_joinRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__User__joinRoom_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__User__joinRoom_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(room);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::User::end_joinRoom(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Chat__User__joinRoom_name);
}

void
IceProxy::Chat::User::exitRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__User__exitRoom_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::User* __del = dynamic_cast< ::IceDelegate::Chat::User*>(__delBase.get());
            __del->exitRoom(room, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::User::begin_exitRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__User__exitRoom_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__User__exitRoom_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(room);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::User::end_exitRoom(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Chat__User__exitRoom_name);
}

::Chat::chatRoomList
IceProxy::Chat::User::getRooms(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__User__getRooms_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__User__getRooms_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::User* __del = dynamic_cast< ::IceDelegate::Chat::User*>(__delBase.get());
            return __del->getRooms(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::User::begin_getRooms(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__User__getRooms_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__User__getRooms_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__User__getRooms_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Chat::chatRoomList
IceProxy::Chat::User::end_getRooms(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__User__getRooms_name);
    ::Chat::chatRoomList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Chat::ChatRoomPrx
IceProxy::Chat::User::findRoomByName(const ::std::string& roomName, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__User__findRoomByName_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__User__findRoomByName_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::User* __del = dynamic_cast< ::IceDelegate::Chat::User*>(__delBase.get());
            return __del->findRoomByName(roomName, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::User::begin_findRoomByName(const ::std::string& roomName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__User__findRoomByName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__User__findRoomByName_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__User__findRoomByName_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(roomName);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Chat::ChatRoomPrx
IceProxy::Chat::User::end_findRoomByName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__User__findRoomByName_name);
    ::Chat::ChatRoomPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Chat::RoomNotFound&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::std::string
IceProxy::Chat::User::getResponseForChallenge(const ::std::string& challenge, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__User__getResponseForChallenge_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__User__getResponseForChallenge_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::User* __del = dynamic_cast< ::IceDelegate::Chat::User*>(__delBase.get());
            return __del->getResponseForChallenge(challenge, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::User::begin_getResponseForChallenge(const ::std::string& challenge, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__User__getResponseForChallenge_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__User__getResponseForChallenge_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__User__getResponseForChallenge_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(challenge);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::Chat::User::end_getResponseForChallenge(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__User__getResponseForChallenge_name);
    ::std::string __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Chat::User::ice_staticId()
{
    return ::Chat::User::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Chat::User::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Chat::User);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Chat::User::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Chat::User);
}

::IceProxy::Ice::Object*
IceProxy::Chat::User::__newInstance() const
{
    return new User;
}
::IceProxy::Ice::Object* ::IceProxy::Chat::upCast(::IceProxy::Chat::ChatServer* p) { return p; }

void
::IceProxy::Chat::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatServer>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Chat::ChatServer;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Chat::ChatServer::registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatServer__registerUser_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__ChatServer__registerUser_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatServer* __del = dynamic_cast< ::IceDelegate::Chat::ChatServer*>(__delBase.get());
            __del->registerUser(username, challengePattern, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::begin_registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__ChatServer__registerUser_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatServer__registerUser_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatServer__registerUser_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(username);
        __os->write(challengePattern);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::ChatServer::end_registerUser(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__ChatServer__registerUser_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Chat::EmptyUsername&)
            {
                throw;
            }
            catch(const ::Chat::UserAlreadyRegistered&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Chat::ChatServer::login(const ::Chat::UserPrx& u, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatServer__login_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__ChatServer__login_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatServer* __del = dynamic_cast< ::IceDelegate::Chat::ChatServer*>(__delBase.get());
            __del->login(u, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::begin_login(const ::Chat::UserPrx& u, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__ChatServer__login_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatServer__login_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatServer__login_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(u);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::ChatServer::end_login(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__ChatServer__login_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Chat::AuthenticationError&)
            {
                throw;
            }
            catch(const ::Chat::EmptyUsername&)
            {
                throw;
            }
            catch(const ::Chat::UserNotFound&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Chat::ChatServer::enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatServer__enterRoom_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__ChatServer__enterRoom_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatServer* __del = dynamic_cast< ::IceDelegate::Chat::ChatServer*>(__delBase.get());
            __del->enterRoom(u, room, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::begin_enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__ChatServer__enterRoom_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatServer__enterRoom_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatServer__enterRoom_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(u);
        __os->write(room);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::ChatServer::end_enterRoom(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__ChatServer__enterRoom_name);
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Chat::FactoryNotRegistered&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        __result->__readEmptyParams();
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Chat::ChatServer::exitRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatServer__exitRoom_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatServer* __del = dynamic_cast< ::IceDelegate::Chat::ChatServer*>(__delBase.get());
            __del->exitRoom(u, room, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::begin_exitRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatServer__exitRoom_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatServer__exitRoom_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(u);
        __os->write(room);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::ChatServer::end_exitRoom(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Chat__ChatServer__exitRoom_name);
}

void
IceProxy::Chat::ChatServer::logout(const ::Chat::UserPrx& u, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatServer__logout_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatServer* __del = dynamic_cast< ::IceDelegate::Chat::ChatServer*>(__delBase.get());
            __del->logout(u, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::begin_logout(const ::Chat::UserPrx& u, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatServer__logout_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatServer__logout_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(u);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::ChatServer::end_logout(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Chat__ChatServer__logout_name);
}

bool
IceProxy::Chat::ChatServer::isLoggedIn(const ::Chat::UserPrx& u, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatServer__isLoggedIn_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__ChatServer__isLoggedIn_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatServer* __del = dynamic_cast< ::IceDelegate::Chat::ChatServer*>(__delBase.get());
            return __del->isLoggedIn(u, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::begin_isLoggedIn(const ::Chat::UserPrx& u, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__ChatServer__isLoggedIn_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatServer__isLoggedIn_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatServer__isLoggedIn_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(u);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

bool
IceProxy::Chat::ChatServer::end_isLoggedIn(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__ChatServer__isLoggedIn_name);
    bool __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Chat::chatRoomList
IceProxy::Chat::ChatServer::getRooms(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatServer__getRooms_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__ChatServer__getRooms_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatServer* __del = dynamic_cast< ::IceDelegate::Chat::ChatServer*>(__delBase.get());
            return __del->getRooms(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::begin_getRooms(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__ChatServer__getRooms_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatServer__getRooms_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatServer__getRooms_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Chat::chatRoomList
IceProxy::Chat::ChatServer::end_getRooms(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__ChatServer__getRooms_name);
    ::Chat::chatRoomList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Chat::ChatRoomPrx
IceProxy::Chat::ChatServer::findRoomByName(const ::std::string& roomName, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatServer__findRoomByName_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__ChatServer__findRoomByName_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatServer* __del = dynamic_cast< ::IceDelegate::Chat::ChatServer*>(__delBase.get());
            return __del->findRoomByName(roomName, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::begin_findRoomByName(const ::std::string& roomName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__ChatServer__findRoomByName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatServer__findRoomByName_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatServer__findRoomByName_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(roomName);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Chat::ChatRoomPrx
IceProxy::Chat::ChatServer::end_findRoomByName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__ChatServer__findRoomByName_name);
    ::Chat::ChatRoomPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Chat::RoomNotFound&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Chat::UserPrx
IceProxy::Chat::ChatServer::findUserByName(const ::std::string& username, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatServer__findUserByName_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__ChatServer__findUserByName_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatServer* __del = dynamic_cast< ::IceDelegate::Chat::ChatServer*>(__delBase.get());
            return __del->findUserByName(username, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::begin_findUserByName(const ::std::string& username, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__ChatServer__findUserByName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatServer__findUserByName_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatServer__findUserByName_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(username);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Chat::UserPrx
IceProxy::Chat::ChatServer::end_findUserByName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__ChatServer__findUserByName_name);
    ::Chat::UserPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Chat::UserNotFound&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Chat::ChatServer::registerChatFactory(const ::Chat::ChatFactoryPrx& cf, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatServer__registerChatFactory_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatServer* __del = dynamic_cast< ::IceDelegate::Chat::ChatServer*>(__delBase.get());
            __del->registerChatFactory(cf, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatServer::begin_registerChatFactory(const ::Chat::ChatFactoryPrx& cf, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatServer__registerChatFactory_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatServer__registerChatFactory_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(cf);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::ChatServer::end_registerChatFactory(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Chat__ChatServer__registerChatFactory_name);
}

const ::std::string&
IceProxy::Chat::ChatServer::ice_staticId()
{
    return ::Chat::ChatServer::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Chat::ChatServer::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Chat::ChatServer);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Chat::ChatServer::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Chat::ChatServer);
}

::IceProxy::Ice::Object*
IceProxy::Chat::ChatServer::__newInstance() const
{
    return new ChatServer;
}
::IceProxy::Ice::Object* ::IceProxy::Chat::upCast(::IceProxy::Chat::ChatRoom* p) { return p; }

void
::IceProxy::Chat::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatRoom>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Chat::ChatRoom;
        v->__copyFrom(proxy);
    }
}

void
IceProxy::Chat::ChatRoom::sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatRoom__sendMessageToAll_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatRoom* __del = dynamic_cast< ::IceDelegate::Chat::ChatRoom*>(__delBase.get());
            __del->sendMessageToAll(who, message, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatRoom::begin_sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatRoom__sendMessageToAll_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatRoom__sendMessageToAll_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(who);
        __os->write(message);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::ChatRoom::end_sendMessageToAll(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Chat__ChatRoom__sendMessageToAll_name);
}

::std::string
IceProxy::Chat::ChatRoom::getName(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatRoom__getName_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__ChatRoom__getName_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatRoom* __del = dynamic_cast< ::IceDelegate::Chat::ChatRoom*>(__delBase.get());
            return __del->getName(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatRoom::begin_getName(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__ChatRoom__getName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatRoom__getName_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatRoom__getName_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::std::string
IceProxy::Chat::ChatRoom::end_getName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__ChatRoom__getName_name);
    ::std::string __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

void
IceProxy::Chat::ChatRoom::setName(const ::std::string& name, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatRoom__setName_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatRoom* __del = dynamic_cast< ::IceDelegate::Chat::ChatRoom*>(__delBase.get());
            __del->setName(name, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatRoom::begin_setName(const ::std::string& name, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatRoom__setName_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatRoom__setName_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::ChatRoom::end_setName(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Chat__ChatRoom__setName_name);
}

void
IceProxy::Chat::ChatRoom::enterRoom(const ::Chat::UserPrx& u, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatRoom__enterRoom_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatRoom* __del = dynamic_cast< ::IceDelegate::Chat::ChatRoom*>(__delBase.get());
            __del->enterRoom(u, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatRoom::begin_enterRoom(const ::Chat::UserPrx& u, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatRoom__enterRoom_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatRoom__enterRoom_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(u);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::ChatRoom::end_enterRoom(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Chat__ChatRoom__enterRoom_name);
}

void
IceProxy::Chat::ChatRoom::exitRoom(const ::Chat::UserPrx& u, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatRoom__exitRoom_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatRoom* __del = dynamic_cast< ::IceDelegate::Chat::ChatRoom*>(__delBase.get());
            __del->exitRoom(u, __ctx, __observer);
            return;
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatRoom::begin_exitRoom(const ::Chat::UserPrx& u, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatRoom__exitRoom_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatRoom__exitRoom_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(u);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

void
IceProxy::Chat::ChatRoom::end_exitRoom(const ::Ice::AsyncResultPtr& __result)
{
    __end(__result, __Chat__ChatRoom__exitRoom_name);
}

::Chat::userList
IceProxy::Chat::ChatRoom::getUsers(const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatRoom__getUsers_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__ChatRoom__getUsers_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatRoom* __del = dynamic_cast< ::IceDelegate::Chat::ChatRoom*>(__delBase.get());
            return __del->getUsers(__ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatRoom::begin_getUsers(const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__ChatRoom__getUsers_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatRoom__getUsers_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatRoom__getUsers_name, ::Ice::Normal, __ctx);
        __result->__writeEmptyParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Chat::userList
IceProxy::Chat::ChatRoom::end_getUsers(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__ChatRoom__getUsers_name);
    ::Chat::userList __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

::Chat::UserPrx
IceProxy::Chat::ChatRoom::findUserByName(const ::std::string& username, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatRoom__findUserByName_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__ChatRoom__findUserByName_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatRoom* __del = dynamic_cast< ::IceDelegate::Chat::ChatRoom*>(__delBase.get());
            return __del->findUserByName(username, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatRoom::begin_findUserByName(const ::std::string& username, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__ChatRoom__findUserByName_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatRoom__findUserByName_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatRoom__findUserByName_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(username);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Chat::UserPrx
IceProxy::Chat::ChatRoom::end_findUserByName(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__ChatRoom__findUserByName_name);
    ::Chat::UserPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Chat::UserNotFound&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Chat::ChatRoom::ice_staticId()
{
    return ::Chat::ChatRoom::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Chat::ChatRoom::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Chat::ChatRoom);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Chat::ChatRoom::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Chat::ChatRoom);
}

::IceProxy::Ice::Object*
IceProxy::Chat::ChatRoom::__newInstance() const
{
    return new ChatRoom;
}
::IceProxy::Ice::Object* ::IceProxy::Chat::upCast(::IceProxy::Chat::ChatFactory* p) { return p; }

void
::IceProxy::Chat::__read(::IceInternal::BasicStream* __is, ::IceInternal::ProxyHandle< ::IceProxy::Chat::ChatFactory>& v)
{
    ::Ice::ObjectPrx proxy;
    __is->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ::IceProxy::Chat::ChatFactory;
        v->__copyFrom(proxy);
    }
}

::Chat::ChatRoomPrx
IceProxy::Chat::ChatFactory::getNewChatRoom(const ::std::string& roomName, const ::Ice::Context* __ctx)
{
    ::IceInternal::InvocationObserver __observer(this, __Chat__ChatFactory__getNewChatRoom_name, __ctx);
    int __cnt = 0;
    while(true)
    {
        ::IceInternal::Handle< ::IceDelegate::Ice::Object> __delBase;
        try
        {
            __checkTwowayOnly(__Chat__ChatFactory__getNewChatRoom_name);
            __delBase = __getDelegate(false);
            ::IceDelegate::Chat::ChatFactory* __del = dynamic_cast< ::IceDelegate::Chat::ChatFactory*>(__delBase.get());
            return __del->getNewChatRoom(roomName, __ctx, __observer);
        }
        catch(const ::IceInternal::LocalExceptionWrapper& __ex)
        {
            __handleExceptionWrapper(__delBase, __ex, __observer);
        }
        catch(const ::Ice::LocalException& __ex)
        {
            __handleException(__delBase, __ex, true, __cnt, __observer);
        }
    }
}

::Ice::AsyncResultPtr
IceProxy::Chat::ChatFactory::begin_getNewChatRoom(const ::std::string& roomName, const ::Ice::Context* __ctx, const ::IceInternal::CallbackBasePtr& __del, const ::Ice::LocalObjectPtr& __cookie)
{
    __checkAsyncTwowayOnly(__Chat__ChatFactory__getNewChatRoom_name);
    ::IceInternal::OutgoingAsyncPtr __result = new ::IceInternal::OutgoingAsync(this, __Chat__ChatFactory__getNewChatRoom_name, __del, __cookie);
    try
    {
        __result->__prepare(__Chat__ChatFactory__getNewChatRoom_name, ::Ice::Normal, __ctx);
        ::IceInternal::BasicStream* __os = __result->__startWriteParams(::Ice::DefaultFormat);
        __os->write(roomName);
        __result->__endWriteParams();
        __result->__send(true);
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __result->__exceptionAsync(__ex);
    }
    return __result;
}

::Chat::ChatRoomPrx
IceProxy::Chat::ChatFactory::end_getNewChatRoom(const ::Ice::AsyncResultPtr& __result)
{
    ::Ice::AsyncResult::__check(__result, this, __Chat__ChatFactory__getNewChatRoom_name);
    ::Chat::ChatRoomPrx __ret;
    bool __ok = __result->__wait();
    try
    {
        if(!__ok)
        {
            try
            {
                __result->__throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                throw ::Ice::UnknownUserException(__FILE__, __LINE__, __ex.ice_name());
            }
        }
        ::IceInternal::BasicStream* __is = __result->__startReadParams();
        __is->read(__ret);
        __result->__endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& ex)
    {
        __result->__getObserver().failed(ex.ice_name());
        throw;
    }
}

const ::std::string&
IceProxy::Chat::ChatFactory::ice_staticId()
{
    return ::Chat::ChatFactory::ice_staticId();
}

::IceInternal::Handle< ::IceDelegateM::Ice::Object>
IceProxy::Chat::ChatFactory::__createDelegateM()
{
    return ::IceInternal::Handle< ::IceDelegateM::Ice::Object>(new ::IceDelegateM::Chat::ChatFactory);
}

::IceInternal::Handle< ::IceDelegateD::Ice::Object>
IceProxy::Chat::ChatFactory::__createDelegateD()
{
    return ::IceInternal::Handle< ::IceDelegateD::Ice::Object>(new ::IceDelegateD::Chat::ChatFactory);
}

::IceProxy::Ice::Object*
IceProxy::Chat::ChatFactory::__newInstance() const
{
    return new ChatFactory;
}

void
IceDelegateM::Chat::User::sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__User__sendMessage_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(message);
        __os->write(room);
        __os->write(who);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Chat::User::sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__User__sendPrivateMessage_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(message);
        __os->write(who);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Chat::User::displayMessage(const ::std::string& message, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__User__displayMessage_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(message);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::std::string
IceDelegateM::Chat::User::getName(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__User__getName_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Chat::User::setName(const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__User__setName_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Chat::User::setPattern(const ::std::string& pattern, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__User__setPattern_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(pattern);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Chat::User::joinRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__User__joinRoom_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(room);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Chat::User::exitRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__User__exitRoom_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(room);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Chat::chatRoomList
IceDelegateM::Chat::User::getRooms(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__User__getRooms_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Chat::chatRoomList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Chat::ChatRoomPrx
IceDelegateM::Chat::User::findRoomByName(const ::std::string& roomName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__User__findRoomByName_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(roomName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Chat::ChatRoomPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Chat::RoomNotFound&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::std::string
IceDelegateM::Chat::User::getResponseForChallenge(const ::std::string& challenge, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__User__getResponseForChallenge_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(challenge);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Chat::ChatServer::registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatServer__registerUser_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(username);
        __os->write(challengePattern);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Chat::EmptyUsername&)
            {
                throw;
            }
            catch(const ::Chat::UserAlreadyRegistered&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Chat::ChatServer::login(const ::Chat::UserPrx& u, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatServer__login_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(u);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Chat::AuthenticationError&)
            {
                throw;
            }
            catch(const ::Chat::EmptyUsername&)
            {
                throw;
            }
            catch(const ::Chat::UserNotFound&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Chat::ChatServer::enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatServer__enterRoom_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(u);
        __os->write(room);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Chat::FactoryNotRegistered&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        __og.readEmptyParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Chat::ChatServer::exitRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatServer__exitRoom_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(u);
        __os->write(room);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Chat::ChatServer::logout(const ::Chat::UserPrx& u, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatServer__logout_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(u);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

bool
IceDelegateM::Chat::ChatServer::isLoggedIn(const ::Chat::UserPrx& u, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatServer__isLoggedIn_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(u);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    bool __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Chat::chatRoomList
IceDelegateM::Chat::ChatServer::getRooms(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatServer__getRooms_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Chat::chatRoomList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Chat::ChatRoomPrx
IceDelegateM::Chat::ChatServer::findRoomByName(const ::std::string& roomName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatServer__findRoomByName_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(roomName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Chat::ChatRoomPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Chat::RoomNotFound&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Chat::UserPrx
IceDelegateM::Chat::ChatServer::findUserByName(const ::std::string& username, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatServer__findUserByName_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(username);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Chat::UserPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Chat::UserNotFound&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Chat::ChatServer::registerChatFactory(const ::Chat::ChatFactoryPrx& cf, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatServer__registerChatFactory_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(cf);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Chat::ChatRoom::sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatRoom__sendMessageToAll_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(who);
        __os->write(message);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::std::string
IceDelegateM::Chat::ChatRoom::getName(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatRoom__getName_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::std::string __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateM::Chat::ChatRoom::setName(const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatRoom__setName_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(name);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Chat::ChatRoom::enterRoom(const ::Chat::UserPrx& u, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatRoom__enterRoom_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(u);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

void
IceDelegateM::Chat::ChatRoom::exitRoom(const ::Chat::UserPrx& u, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatRoom__exitRoom_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(u);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    if(__og.hasResponse())
    {
        try
        {
            if(!__ok)
            {
                try
                {
                    __og.throwUserException();
                }
                catch(const ::Ice::UserException& __ex)
                {
                    ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                    throw __uue;
                }
            }
            __og.readEmptyParams();
        }
        catch(const ::Ice::LocalException& __ex)
        {
            throw ::IceInternal::LocalExceptionWrapper(__ex, false);
        }
    }
}

::Chat::userList
IceDelegateM::Chat::ChatRoom::getUsers(const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatRoom__getUsers_name, ::Ice::Normal, __context, __observer);
    __og.writeEmptyParams();
    bool __ok = __og.invoke();
    ::Chat::userList __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Chat::UserPrx
IceDelegateM::Chat::ChatRoom::findUserByName(const ::std::string& username, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatRoom__findUserByName_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(username);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Chat::UserPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Chat::UserNotFound&)
            {
                throw;
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

::Chat::ChatRoomPrx
IceDelegateM::Chat::ChatFactory::getNewChatRoom(const ::std::string& roomName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver& __observer)
{
    ::IceInternal::Outgoing __og(__handler.get(), __Chat__ChatFactory__getNewChatRoom_name, ::Ice::Normal, __context, __observer);
    try
    {
        ::IceInternal::BasicStream* __os = __og.startWriteParams(::Ice::DefaultFormat);
        __os->write(roomName);
        __og.endWriteParams();
    }
    catch(const ::Ice::LocalException& __ex)
    {
        __og.abort(__ex);
    }
    bool __ok = __og.invoke();
    ::Chat::ChatRoomPrx __ret;
    try
    {
        if(!__ok)
        {
            try
            {
                __og.throwUserException();
            }
            catch(const ::Ice::UserException& __ex)
            {
                ::Ice::UnknownUserException __uue(__FILE__, __LINE__, __ex.ice_name());
                throw __uue;
            }
        }
        ::IceInternal::BasicStream* __is = __og.startReadParams();
        __is->read(__ret);
        __og.endReadParams();
        return __ret;
    }
    catch(const ::Ice::LocalException& __ex)
    {
        throw ::IceInternal::LocalExceptionWrapper(__ex, false);
    }
}

void
IceDelegateD::Chat::User::sendMessage(const ::std::string& message, const ::Chat::ChatRoomPrx& room, const ::Chat::UserPrx& who, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_message, const ::Chat::ChatRoomPrx& __p_room, const ::Chat::UserPrx& __p_who, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_message(__p_message),
            _m_room(__p_room),
            _m_who(__p_who)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::User* servant = dynamic_cast< ::Chat::User*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->sendMessage(_m_message, _m_room, _m_who, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_message;
        const ::Chat::ChatRoomPrx& _m_room;
        const ::Chat::UserPrx& _m_who;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__User__sendMessage_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(message, room, who, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Chat::User::sendPrivateMessage(const ::std::string& message, const ::Chat::UserPrx& who, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_message, const ::Chat::UserPrx& __p_who, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_message(__p_message),
            _m_who(__p_who)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::User* servant = dynamic_cast< ::Chat::User*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->sendPrivateMessage(_m_message, _m_who, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_message;
        const ::Chat::UserPrx& _m_who;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__User__sendPrivateMessage_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(message, who, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Chat::User::displayMessage(const ::std::string& message, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_message, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_message(__p_message)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::User* servant = dynamic_cast< ::Chat::User*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->displayMessage(_m_message, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_message;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__User__displayMessage_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(message, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::std::string
IceDelegateD::Chat::User::getName(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::User* servant = dynamic_cast< ::Chat::User*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getName(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__User__getName_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::Chat::User::setName(const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_name, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_name(__p_name)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::User* servant = dynamic_cast< ::Chat::User*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setName(_m_name, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_name;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__User__setName_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(name, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Chat::User::setPattern(const ::std::string& pattern, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_pattern, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_pattern(__p_pattern)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::User* servant = dynamic_cast< ::Chat::User*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setPattern(_m_pattern, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_pattern;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__User__setPattern_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(pattern, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Chat::User::joinRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Chat::ChatRoomPrx& __p_room, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_room(__p_room)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::User* servant = dynamic_cast< ::Chat::User*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->joinRoom(_m_room, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Chat::ChatRoomPrx& _m_room;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__User__joinRoom_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(room, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Chat::User::exitRoom(const ::Chat::ChatRoomPrx& room, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Chat::ChatRoomPrx& __p_room, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_room(__p_room)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::User* servant = dynamic_cast< ::Chat::User*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->exitRoom(_m_room, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Chat::ChatRoomPrx& _m_room;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__User__exitRoom_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(room, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Chat::chatRoomList
IceDelegateD::Chat::User::getRooms(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Chat::chatRoomList& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::User* servant = dynamic_cast< ::Chat::User*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getRooms(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Chat::chatRoomList& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__User__getRooms_name, ::Ice::Normal, __context);
    ::Chat::chatRoomList __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Chat::ChatRoomPrx
IceDelegateD::Chat::User::findRoomByName(const ::std::string& roomName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Chat::ChatRoomPrx& __result, const ::std::string& __p_roomName, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_roomName(__p_roomName)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::User* servant = dynamic_cast< ::Chat::User*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->findRoomByName(_m_roomName, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Chat::ChatRoomPrx& _result;
        const ::std::string& _m_roomName;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__User__findRoomByName_name, ::Ice::Normal, __context);
    ::Chat::ChatRoomPrx __result;
    try
    {
        _DirectI __direct(__result, roomName, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Chat::RoomNotFound&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::std::string
IceDelegateD::Chat::User::getResponseForChallenge(const ::std::string& challenge, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::std::string& __p_challenge, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_challenge(__p_challenge)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::User* servant = dynamic_cast< ::Chat::User*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getResponseForChallenge(_m_challenge, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
        const ::std::string& _m_challenge;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__User__getResponseForChallenge_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, challenge, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::Chat::ChatServer::registerUser(const ::std::string& username, const ::std::string& challengePattern, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_username, const ::std::string& __p_challengePattern, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_username(__p_username),
            _m_challengePattern(__p_challengePattern)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatServer* servant = dynamic_cast< ::Chat::ChatServer*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->registerUser(_m_username, _m_challengePattern, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::std::string& _m_username;
        const ::std::string& _m_challengePattern;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatServer__registerUser_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(username, challengePattern, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Chat::EmptyUsername&)
    {
        throw;
    }
    catch(const ::Chat::UserAlreadyRegistered&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Chat::ChatServer::login(const ::Chat::UserPrx& u, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Chat::UserPrx& __p_u, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_u(__p_u)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatServer* servant = dynamic_cast< ::Chat::ChatServer*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->login(_m_u, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::Chat::UserPrx& _m_u;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatServer__login_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(u, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Chat::AuthenticationError&)
    {
        throw;
    }
    catch(const ::Chat::EmptyUsername&)
    {
        throw;
    }
    catch(const ::Chat::UserNotFound&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Chat::ChatServer::enterRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Chat::UserPrx& __p_u, const ::std::string& __p_room, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_u(__p_u),
            _m_room(__p_room)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatServer* servant = dynamic_cast< ::Chat::ChatServer*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                servant->enterRoom(_m_u, _m_room, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        const ::Chat::UserPrx& _m_u;
        const ::std::string& _m_room;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatServer__enterRoom_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(u, room, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Chat::FactoryNotRegistered&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Chat::ChatServer::exitRoom(const ::Chat::UserPrx& u, const ::std::string& room, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Chat::UserPrx& __p_u, const ::std::string& __p_room, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_u(__p_u),
            _m_room(__p_room)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatServer* servant = dynamic_cast< ::Chat::ChatServer*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->exitRoom(_m_u, _m_room, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Chat::UserPrx& _m_u;
        const ::std::string& _m_room;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatServer__exitRoom_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(u, room, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Chat::ChatServer::logout(const ::Chat::UserPrx& u, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Chat::UserPrx& __p_u, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_u(__p_u)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatServer* servant = dynamic_cast< ::Chat::ChatServer*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->logout(_m_u, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Chat::UserPrx& _m_u;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatServer__logout_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(u, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

bool
IceDelegateD::Chat::ChatServer::isLoggedIn(const ::Chat::UserPrx& u, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(bool& __result, const ::Chat::UserPrx& __p_u, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_u(__p_u)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatServer* servant = dynamic_cast< ::Chat::ChatServer*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->isLoggedIn(_m_u, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        bool& _result;
        const ::Chat::UserPrx& _m_u;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatServer__isLoggedIn_name, ::Ice::Normal, __context);
    bool __result;
    try
    {
        _DirectI __direct(__result, u, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Chat::chatRoomList
IceDelegateD::Chat::ChatServer::getRooms(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Chat::chatRoomList& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatServer* servant = dynamic_cast< ::Chat::ChatServer*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getRooms(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Chat::chatRoomList& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatServer__getRooms_name, ::Ice::Normal, __context);
    ::Chat::chatRoomList __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Chat::ChatRoomPrx
IceDelegateD::Chat::ChatServer::findRoomByName(const ::std::string& roomName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Chat::ChatRoomPrx& __result, const ::std::string& __p_roomName, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_roomName(__p_roomName)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatServer* servant = dynamic_cast< ::Chat::ChatServer*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->findRoomByName(_m_roomName, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Chat::ChatRoomPrx& _result;
        const ::std::string& _m_roomName;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatServer__findRoomByName_name, ::Ice::Normal, __context);
    ::Chat::ChatRoomPrx __result;
    try
    {
        _DirectI __direct(__result, roomName, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Chat::RoomNotFound&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Chat::UserPrx
IceDelegateD::Chat::ChatServer::findUserByName(const ::std::string& username, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Chat::UserPrx& __result, const ::std::string& __p_username, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_username(__p_username)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatServer* servant = dynamic_cast< ::Chat::ChatServer*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->findUserByName(_m_username, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Chat::UserPrx& _result;
        const ::std::string& _m_username;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatServer__findUserByName_name, ::Ice::Normal, __context);
    ::Chat::UserPrx __result;
    try
    {
        _DirectI __direct(__result, username, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Chat::UserNotFound&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::Chat::ChatServer::registerChatFactory(const ::Chat::ChatFactoryPrx& cf, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Chat::ChatFactoryPrx& __p_cf, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_cf(__p_cf)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatServer* servant = dynamic_cast< ::Chat::ChatServer*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->registerChatFactory(_m_cf, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Chat::ChatFactoryPrx& _m_cf;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatServer__registerChatFactory_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(cf, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Chat::ChatRoom::sendMessageToAll(const ::Chat::UserPrx& who, const ::std::string& message, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Chat::UserPrx& __p_who, const ::std::string& __p_message, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_who(__p_who),
            _m_message(__p_message)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatRoom* servant = dynamic_cast< ::Chat::ChatRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->sendMessageToAll(_m_who, _m_message, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Chat::UserPrx& _m_who;
        const ::std::string& _m_message;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatRoom__sendMessageToAll_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(who, message, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::std::string
IceDelegateD::Chat::ChatRoom::getName(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::std::string& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatRoom* servant = dynamic_cast< ::Chat::ChatRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getName(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::std::string& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatRoom__getName_name, ::Ice::Normal, __context);
    ::std::string __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

void
IceDelegateD::Chat::ChatRoom::setName(const ::std::string& name, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::std::string& __p_name, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_name(__p_name)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatRoom* servant = dynamic_cast< ::Chat::ChatRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->setName(_m_name, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::std::string& _m_name;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatRoom__setName_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(name, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Chat::ChatRoom::enterRoom(const ::Chat::UserPrx& u, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Chat::UserPrx& __p_u, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_u(__p_u)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatRoom* servant = dynamic_cast< ::Chat::ChatRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->enterRoom(_m_u, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Chat::UserPrx& _m_u;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatRoom__enterRoom_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(u, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

void
IceDelegateD::Chat::ChatRoom::exitRoom(const ::Chat::UserPrx& u, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(const ::Chat::UserPrx& __p_u, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _m_u(__p_u)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatRoom* servant = dynamic_cast< ::Chat::ChatRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            servant->exitRoom(_m_u, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        const ::Chat::UserPrx& _m_u;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatRoom__exitRoom_name, ::Ice::Normal, __context);
    try
    {
        _DirectI __direct(u, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
}

::Chat::userList
IceDelegateD::Chat::ChatRoom::getUsers(const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Chat::userList& __result, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatRoom* servant = dynamic_cast< ::Chat::ChatRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getUsers(_current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Chat::userList& _result;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatRoom__getUsers_name, ::Ice::Normal, __context);
    ::Chat::userList __result;
    try
    {
        _DirectI __direct(__result, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Chat::UserPrx
IceDelegateD::Chat::ChatRoom::findUserByName(const ::std::string& username, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Chat::UserPrx& __result, const ::std::string& __p_username, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_username(__p_username)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatRoom* servant = dynamic_cast< ::Chat::ChatRoom*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            try
            {
                _result = servant->findUserByName(_m_username, _current);
                return ::Ice::DispatchOK;
            }
            catch(const ::Ice::UserException& __ex)
            {
                setUserException(__ex);
                return ::Ice::DispatchUserException;
            }
        }
        
    private:
        
        ::Chat::UserPrx& _result;
        const ::std::string& _m_username;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatRoom__findUserByName_name, ::Ice::Normal, __context);
    ::Chat::UserPrx __result;
    try
    {
        _DirectI __direct(__result, username, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Chat::UserNotFound&)
    {
        throw;
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Chat::ChatRoomPrx
IceDelegateD::Chat::ChatFactory::getNewChatRoom(const ::std::string& roomName, const ::Ice::Context* __context, ::IceInternal::InvocationObserver&)
{
    class _DirectI : public ::IceInternal::Direct
    {
    public:

        _DirectI(::Chat::ChatRoomPrx& __result, const ::std::string& __p_roomName, const ::Ice::Current& __current) : 
            ::IceInternal::Direct(__current),
            _result(__result),
            _m_roomName(__p_roomName)
        {
        }
        
        virtual ::Ice::DispatchStatus
        run(::Ice::Object* object)
        {
            ::Chat::ChatFactory* servant = dynamic_cast< ::Chat::ChatFactory*>(object);
            if(!servant)
            {
                throw ::Ice::OperationNotExistException(__FILE__, __LINE__, _current.id, _current.facet, _current.operation);
            }
            _result = servant->getNewChatRoom(_m_roomName, _current);
            return ::Ice::DispatchOK;
        }
        
    private:
        
        ::Chat::ChatRoomPrx& _result;
        const ::std::string& _m_roomName;
    };
    
    ::Ice::Current __current;
    __initCurrent(__current, __Chat__ChatFactory__getNewChatRoom_name, ::Ice::Normal, __context);
    ::Chat::ChatRoomPrx __result;
    try
    {
        _DirectI __direct(__result, roomName, __current);
        try
        {
            __direct.getServant()->__collocDispatch(__direct);
        }
        catch(...)
        {
            __direct.destroy();
            throw;
        }
        __direct.destroy();
    }
    catch(const ::Ice::SystemException&)
    {
        throw;
    }
    catch(const ::IceInternal::LocalExceptionWrapper&)
    {
        throw;
    }
    catch(const ::std::exception& __ex)
    {
        ::IceInternal::LocalExceptionWrapper::throwWrapper(__ex);
    }
    catch(...)
    {
        throw ::IceInternal::LocalExceptionWrapper(::Ice::UnknownException(__FILE__, __LINE__, "unknown c++ exception"), false);
    }
    return __result;
}

::Ice::Object* Chat::upCast(::Chat::User* p) { return p; }

namespace
{
const ::std::string __Chat__User_ids[2] =
{
    "::Chat::User",
    "::Ice::Object"
};

}

bool
Chat::User::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Chat__User_ids, __Chat__User_ids + 2, _s);
}

::std::vector< ::std::string>
Chat::User::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Chat__User_ids[0], &__Chat__User_ids[2]);
}

const ::std::string&
Chat::User::ice_id(const ::Ice::Current&) const
{
    return __Chat__User_ids[0];
}

const ::std::string&
Chat::User::ice_staticId()
{
    return __Chat__User_ids[0];
}

::Ice::DispatchStatus
Chat::User::___sendMessage(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string message;
    ::Chat::ChatRoomPrx room;
    ::Chat::UserPrx who;
    __is->read(message);
    __is->read(room);
    __is->read(who);
    __inS.endReadParams();
    sendMessage(message, room, who, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::User::___sendPrivateMessage(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string message;
    ::Chat::UserPrx who;
    __is->read(message);
    __is->read(who);
    __inS.endReadParams();
    sendPrivateMessage(message, who, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::User::___displayMessage(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string message;
    __is->read(message);
    __inS.endReadParams();
    displayMessage(message, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::User::___getName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::std::string __ret = getName(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::User::___setName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string name;
    __is->read(name);
    __inS.endReadParams();
    setName(name, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::User::___setPattern(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string pattern;
    __is->read(pattern);
    __inS.endReadParams();
    setPattern(pattern, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::User::___joinRoom(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Chat::ChatRoomPrx room;
    __is->read(room);
    __inS.endReadParams();
    joinRoom(room, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::User::___exitRoom(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Chat::ChatRoomPrx room;
    __is->read(room);
    __inS.endReadParams();
    exitRoom(room, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::User::___getRooms(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Chat::chatRoomList __ret = getRooms(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::User::___findRoomByName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string roomName;
    __is->read(roomName);
    __inS.endReadParams();
    try
    {
        ::Chat::ChatRoomPrx __ret = findRoomByName(roomName, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Chat::RoomNotFound& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Chat::User::___getResponseForChallenge(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string challenge;
    __is->read(challenge);
    __inS.endReadParams();
    ::std::string __ret = getResponseForChallenge(challenge, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Chat__User_all[] =
{
    "displayMessage",
    "exitRoom",
    "findRoomByName",
    "getName",
    "getResponseForChallenge",
    "getRooms",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "joinRoom",
    "sendMessage",
    "sendPrivateMessage",
    "setName",
    "setPattern"
};

}

::Ice::DispatchStatus
Chat::User::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Chat__User_all, __Chat__User_all + 15, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Chat__User_all)
    {
        case 0:
        {
            return ___displayMessage(in, current);
        }
        case 1:
        {
            return ___exitRoom(in, current);
        }
        case 2:
        {
            return ___findRoomByName(in, current);
        }
        case 3:
        {
            return ___getName(in, current);
        }
        case 4:
        {
            return ___getResponseForChallenge(in, current);
        }
        case 5:
        {
            return ___getRooms(in, current);
        }
        case 6:
        {
            return ___ice_id(in, current);
        }
        case 7:
        {
            return ___ice_ids(in, current);
        }
        case 8:
        {
            return ___ice_isA(in, current);
        }
        case 9:
        {
            return ___ice_ping(in, current);
        }
        case 10:
        {
            return ___joinRoom(in, current);
        }
        case 11:
        {
            return ___sendMessage(in, current);
        }
        case 12:
        {
            return ___sendPrivateMessage(in, current);
        }
        case 13:
        {
            return ___setName(in, current);
        }
        case 14:
        {
            return ___setPattern(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Chat::User::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Chat::User::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Chat::__patch(UserPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Chat::UserPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Chat::User::ice_staticId(), v);
    }
}

::Ice::Object* Chat::upCast(::Chat::ChatServer* p) { return p; }

namespace
{
const ::std::string __Chat__ChatServer_ids[2] =
{
    "::Chat::ChatServer",
    "::Ice::Object"
};

}

bool
Chat::ChatServer::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Chat__ChatServer_ids, __Chat__ChatServer_ids + 2, _s);
}

::std::vector< ::std::string>
Chat::ChatServer::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Chat__ChatServer_ids[0], &__Chat__ChatServer_ids[2]);
}

const ::std::string&
Chat::ChatServer::ice_id(const ::Ice::Current&) const
{
    return __Chat__ChatServer_ids[0];
}

const ::std::string&
Chat::ChatServer::ice_staticId()
{
    return __Chat__ChatServer_ids[0];
}

::Ice::DispatchStatus
Chat::ChatServer::___registerUser(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string username;
    ::std::string challengePattern;
    __is->read(username);
    __is->read(challengePattern);
    __inS.endReadParams();
    try
    {
        registerUser(username, challengePattern, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Chat::EmptyUsername& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::Chat::UserAlreadyRegistered& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Chat::ChatServer::___login(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Chat::UserPrx u;
    __is->read(u);
    __inS.endReadParams();
    try
    {
        login(u, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Chat::AuthenticationError& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::Chat::EmptyUsername& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    catch(const ::Chat::UserNotFound& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Chat::ChatServer::___enterRoom(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Chat::UserPrx u;
    ::std::string room;
    __is->read(u);
    __is->read(room);
    __inS.endReadParams();
    try
    {
        enterRoom(u, room, __current);
        __inS.__writeEmptyParams();
        return ::Ice::DispatchOK;
    }
    catch(const ::Chat::FactoryNotRegistered& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Chat::ChatServer::___exitRoom(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Chat::UserPrx u;
    ::std::string room;
    __is->read(u);
    __is->read(room);
    __inS.endReadParams();
    exitRoom(u, room, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::ChatServer::___logout(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Chat::UserPrx u;
    __is->read(u);
    __inS.endReadParams();
    logout(u, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::ChatServer::___isLoggedIn(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Chat::UserPrx u;
    __is->read(u);
    __inS.endReadParams();
    bool __ret = isLoggedIn(u, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::ChatServer::___getRooms(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Chat::chatRoomList __ret = getRooms(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::ChatServer::___findRoomByName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string roomName;
    __is->read(roomName);
    __inS.endReadParams();
    try
    {
        ::Chat::ChatRoomPrx __ret = findRoomByName(roomName, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Chat::RoomNotFound& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Chat::ChatServer::___findUserByName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string username;
    __is->read(username);
    __inS.endReadParams();
    try
    {
        ::Chat::UserPrx __ret = findUserByName(username, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Chat::UserNotFound& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

::Ice::DispatchStatus
Chat::ChatServer::___registerChatFactory(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Chat::ChatFactoryPrx cf;
    __is->read(cf);
    __inS.endReadParams();
    registerChatFactory(cf, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Chat__ChatServer_all[] =
{
    "enterRoom",
    "exitRoom",
    "findRoomByName",
    "findUserByName",
    "getRooms",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "isLoggedIn",
    "login",
    "logout",
    "registerChatFactory",
    "registerUser"
};

}

::Ice::DispatchStatus
Chat::ChatServer::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Chat__ChatServer_all, __Chat__ChatServer_all + 14, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Chat__ChatServer_all)
    {
        case 0:
        {
            return ___enterRoom(in, current);
        }
        case 1:
        {
            return ___exitRoom(in, current);
        }
        case 2:
        {
            return ___findRoomByName(in, current);
        }
        case 3:
        {
            return ___findUserByName(in, current);
        }
        case 4:
        {
            return ___getRooms(in, current);
        }
        case 5:
        {
            return ___ice_id(in, current);
        }
        case 6:
        {
            return ___ice_ids(in, current);
        }
        case 7:
        {
            return ___ice_isA(in, current);
        }
        case 8:
        {
            return ___ice_ping(in, current);
        }
        case 9:
        {
            return ___isLoggedIn(in, current);
        }
        case 10:
        {
            return ___login(in, current);
        }
        case 11:
        {
            return ___logout(in, current);
        }
        case 12:
        {
            return ___registerChatFactory(in, current);
        }
        case 13:
        {
            return ___registerUser(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Chat::ChatServer::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Chat::ChatServer::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Chat::__patch(ChatServerPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Chat::ChatServerPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Chat::ChatServer::ice_staticId(), v);
    }
}

::Ice::Object* Chat::upCast(::Chat::ChatRoom* p) { return p; }

namespace
{
const ::std::string __Chat__ChatRoom_ids[2] =
{
    "::Chat::ChatRoom",
    "::Ice::Object"
};

}

bool
Chat::ChatRoom::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Chat__ChatRoom_ids, __Chat__ChatRoom_ids + 2, _s);
}

::std::vector< ::std::string>
Chat::ChatRoom::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Chat__ChatRoom_ids[0], &__Chat__ChatRoom_ids[2]);
}

const ::std::string&
Chat::ChatRoom::ice_id(const ::Ice::Current&) const
{
    return __Chat__ChatRoom_ids[0];
}

const ::std::string&
Chat::ChatRoom::ice_staticId()
{
    return __Chat__ChatRoom_ids[0];
}

::Ice::DispatchStatus
Chat::ChatRoom::___sendMessageToAll(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Chat::UserPrx who;
    ::std::string message;
    __is->read(who);
    __is->read(message);
    __inS.endReadParams();
    sendMessageToAll(who, message, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::ChatRoom::___getName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::std::string __ret = getName(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::ChatRoom::___setName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string name;
    __is->read(name);
    __inS.endReadParams();
    setName(name, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::ChatRoom::___enterRoom(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Chat::UserPrx u;
    __is->read(u);
    __inS.endReadParams();
    enterRoom(u, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::ChatRoom::___exitRoom(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::Chat::UserPrx u;
    __is->read(u);
    __inS.endReadParams();
    exitRoom(u, __current);
    __inS.__writeEmptyParams();
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::ChatRoom::___getUsers(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    __inS.readEmptyParams();
    ::Chat::userList __ret = getUsers(__current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

::Ice::DispatchStatus
Chat::ChatRoom::___findUserByName(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string username;
    __is->read(username);
    __inS.endReadParams();
    try
    {
        ::Chat::UserPrx __ret = findUserByName(username, __current);
        ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
        __os->write(__ret);
        __inS.__endWriteParams(true);
        return ::Ice::DispatchOK;
    }
    catch(const ::Chat::UserNotFound& __ex)
    {
        __inS.__writeUserException(__ex, ::Ice::DefaultFormat);
    }
    return ::Ice::DispatchUserException;
}

namespace
{
const ::std::string __Chat__ChatRoom_all[] =
{
    "enterRoom",
    "exitRoom",
    "findUserByName",
    "getName",
    "getUsers",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping",
    "sendMessageToAll",
    "setName"
};

}

::Ice::DispatchStatus
Chat::ChatRoom::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Chat__ChatRoom_all, __Chat__ChatRoom_all + 11, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Chat__ChatRoom_all)
    {
        case 0:
        {
            return ___enterRoom(in, current);
        }
        case 1:
        {
            return ___exitRoom(in, current);
        }
        case 2:
        {
            return ___findUserByName(in, current);
        }
        case 3:
        {
            return ___getName(in, current);
        }
        case 4:
        {
            return ___getUsers(in, current);
        }
        case 5:
        {
            return ___ice_id(in, current);
        }
        case 6:
        {
            return ___ice_ids(in, current);
        }
        case 7:
        {
            return ___ice_isA(in, current);
        }
        case 8:
        {
            return ___ice_ping(in, current);
        }
        case 9:
        {
            return ___sendMessageToAll(in, current);
        }
        case 10:
        {
            return ___setName(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Chat::ChatRoom::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Chat::ChatRoom::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Chat::__patch(ChatRoomPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Chat::ChatRoomPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Chat::ChatRoom::ice_staticId(), v);
    }
}

::Ice::Object* Chat::upCast(::Chat::ChatFactory* p) { return p; }

namespace
{
const ::std::string __Chat__ChatFactory_ids[2] =
{
    "::Chat::ChatFactory",
    "::Ice::Object"
};

}

bool
Chat::ChatFactory::ice_isA(const ::std::string& _s, const ::Ice::Current&) const
{
    return ::std::binary_search(__Chat__ChatFactory_ids, __Chat__ChatFactory_ids + 2, _s);
}

::std::vector< ::std::string>
Chat::ChatFactory::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&__Chat__ChatFactory_ids[0], &__Chat__ChatFactory_ids[2]);
}

const ::std::string&
Chat::ChatFactory::ice_id(const ::Ice::Current&) const
{
    return __Chat__ChatFactory_ids[0];
}

const ::std::string&
Chat::ChatFactory::ice_staticId()
{
    return __Chat__ChatFactory_ids[0];
}

::Ice::DispatchStatus
Chat::ChatFactory::___getNewChatRoom(::IceInternal::Incoming& __inS, const ::Ice::Current& __current)
{
    __checkMode(::Ice::Normal, __current.mode);
    ::IceInternal::BasicStream* __is = __inS.startReadParams();
    ::std::string roomName;
    __is->read(roomName);
    __inS.endReadParams();
    ::Chat::ChatRoomPrx __ret = getNewChatRoom(roomName, __current);
    ::IceInternal::BasicStream* __os = __inS.__startWriteParams(::Ice::DefaultFormat);
    __os->write(__ret);
    __inS.__endWriteParams(true);
    return ::Ice::DispatchOK;
}

namespace
{
const ::std::string __Chat__ChatFactory_all[] =
{
    "getNewChatRoom",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

::Ice::DispatchStatus
Chat::ChatFactory::__dispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair< const ::std::string*, const ::std::string*> r = ::std::equal_range(__Chat__ChatFactory_all, __Chat__ChatFactory_all + 5, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - __Chat__ChatFactory_all)
    {
        case 0:
        {
            return ___getNewChatRoom(in, current);
        }
        case 1:
        {
            return ___ice_id(in, current);
        }
        case 2:
        {
            return ___ice_ids(in, current);
        }
        case 3:
        {
            return ___ice_isA(in, current);
        }
        case 4:
        {
            return ___ice_ping(in, current);
        }
    }

    assert(false);
    throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
}

void
Chat::ChatFactory::__writeImpl(::IceInternal::BasicStream* __os) const
{
    __os->startWriteSlice(ice_staticId(), -1, true);
    __os->endWriteSlice();
}

void
Chat::ChatFactory::__readImpl(::IceInternal::BasicStream* __is)
{
    __is->startReadSlice();
    __is->endReadSlice();
}

void 
Chat::__patch(ChatFactoryPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ::Chat::ChatFactoryPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(::Chat::ChatFactory::ice_staticId(), v);
    }
}
